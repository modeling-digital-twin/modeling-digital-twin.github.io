{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IoT Modelling for Digital Twins","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the IoT Modelling for Digital Twins documentation. This project focuses on creating comprehensive models for Internet of Things (IoT) systems that can be represented as digital twins in virtual environments.</p>"},{"location":"#what-are-digital-twins","title":"What are Digital Twins?","text":"<p>Digital twins are virtual representations of physical objects, processes, or systems that serve as the real-time digital counterparts of physical entities. In the IoT context, digital twins enable:</p> <ul> <li>Real-time monitoring and visualization</li> <li>Predictive analytics and simulation</li> <li>Enhanced decision-making capabilities</li> <li>Optimized performance and maintenance</li> </ul>"},{"location":"#what-is-caps","title":"What is CAPS?","text":"<p>The CAPS Modeling Framework was created to support the engineering of Situational Aware Cyber-Physical Systems (SiA-CPS). SiA-CPS are systems consisting of a set of IoT devices such as sensors, cameras, RFID, and other monitoring tools used to continuously observe given indoor and outdoor spaces. The data gathered during this process is then transformed into actionable insights.</p> <p>SiA-CPS systems require monitoring in both time and space, meaning they consist of:</p> <ul> <li>Software components (drivers and code running on the sensors)</li> <li>Hardware components (sensors, cameras, RFID, etc.)</li> <li>Environmental interactions (how software and hardware components interact with their surroundings)</li> </ul> <p>Designing such systems poses challenges in ensuring consistency between managing software, hardware, and environmental views. To address this, the CAPS Modeling Framework provides a multi-view approach based on the IEEE/ISO/IEC 42010 standard, ensuring structured and coherent system modeling.</p> <p>For more information, visit: https://caps.disim.univaq.it/</p>"},{"location":"#what-is-cupcarbon","title":"What is CupCarbon","text":"<p>CupCarbon is a comprehensive simulator designed for modeling, visualizing, and analyzing smart city and Internet of Things (IoT) wireless sensor networks (WSNs). It enables users to create and simulate networks directly on geographic maps, allowing realistic placement of nodes and environmental conditions. With support for static and mobile nodes, energy consumption modeling, routing, and communication protocols, CupCarbon provides a powerful environment for testing IoT applications before physical deployment.</p> <p>Researchers, educators, and developers use CupCarbon to experiment with network behaviors, evaluate communication strategies, and validate system architectures in simulated urban or rural environments. Its scripting language (Senscript) allows users to program node behaviors, making it highly customizable for a wide range of IoT and WSN projects.</p> <p>Learn more and download CupCarbon at: https://cupcarbon.com/</p>"},{"location":"#what-is-pdevs","title":"What is PDEVS?","text":"<p>Parallel Discrete Event System Specification (PDEVS) is an extension of the DEVS (Discrete Event System Specification) formalism, providing a structured approach to modeling and simulating complex discrete event systems. PDEVS enhances traditional DEVS by introducing parallel event handling, allowing multiple simultaneous events to be processed in a single simulation step. This improves efficiency and makes it suitable for simulating large-scale, interconnected systems.</p> <p>PDEVS models a system as a set of components (atomic and coupled models) that interact through well-defined input, output, and state transition functions. Each component responds to events over simulated time, enabling hierarchical, modular, and reusable system representations.</p> <p>PDEVS is widely used in fields such as IoT, smart cities, cyber-physical systems, logistics, and distributed systems to simulate dynamic, event-driven behaviors before implementation. It supports both theoretical analysis and practical software simulation frameworks like PyDEVS, MS4 Me, and DEVSJAVA.</p> <p>To learn more, visit: https://en.wikipedia.org/wiki/Discrete_Event_System_Specification https://msdl.uantwerpen.be/documentation/PythonPDEVS/</p> <p>This documentation and the associated codebase are maintained by a team from IIITH. </p> <ul> <li>Maintainer: Likhith Kanigolla</li> <li>Advisor: Dr. Karthik Vaidhyanathan</li> </ul>"},{"location":"caps_installation_guide/","title":"CAPS Installation Guide","text":""},{"location":"caps_installation_guide/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding with the installation, ensure that your system meets the following requirements:</p> <ul> <li>Windows operating system (64-bit)(Tried on Windows expecting same will work for other systems as well)</li> <li>Internet connection</li> <li>Sufficient disk space (at least 5GB free)</li> </ul>"},{"location":"caps_installation_guide/#step-1-download-and-install-java-8","title":"Step 1: Download and Install Java 8","text":"<ol> <li>Visit the Java SE 8 Downloads page.</li> <li>Accept the license agreement and download the Windows x64 JRE.</li> <li>Run the installer and follow the on-screen instructions.</li> <li> <p>Verify the installation by opening the Command Prompt (<code>Win + R</code>, type <code>cmd</code>, and press Enter) and running: <code>sh     java -version</code></p> <p>Ensure it displays Java 1.8.</p> </li> </ol>"},{"location":"caps_installation_guide/#step-2-download-and-install-eclipse-modeling-tools","title":"Step 2: Download and Install Eclipse Modeling Tools","text":"<ol> <li>Visit the Eclipse download page.</li> <li>Download the Eclipse Installer for Windows (64-bit).</li> <li>Run the installer and select Advanced Mode. </li> <li>Choose Eclipse Modeling Tools as the package.</li> <li>Select the Product version as Photon and proceed with the installation and select the Java 1.8</li> <li>Once installed, launch Eclipse.</li> </ol>"},{"location":"caps_installation_guide/#step-3-install-emf","title":"Step 3: Install EMF","text":"<ol> <li>Open Eclipse and go to <code>Help</code> \u2192 <code>Install New Software</code>.</li> <li>In the Work with: field, select All Available Sites.</li> <li>Search for EMF - Eclipse Modeling Framework.</li> <li>Check the box for Eclipse Modeling Framework SDK and proceed with the installation.</li> <li>Restart Eclipse when prompted.</li> </ol>"},{"location":"caps_installation_guide/#step-4-install-gmf-tooling","title":"Step 4: Install GMF Tooling","text":"<ol> <li>Open Eclipse and navigate to <code>Help</code> \u2192 <code>Install New Software</code>.</li> <li>Click on <code>Add...</code> and enter the following: <ul> <li>Name: GMF Tooling</li> <li>Location: <code>https://download.eclipse.org/epsilon/updates/gmf-tooling/</code></li> </ul> </li> <li>Select GMF Tooling and click <code>Next</code>.</li> <li>Complete the installation and restart Eclipse.</li> </ol>"},{"location":"caps_installation_guide/#step-5-install-epsilon","title":"Step 5: Install Epsilon","text":"<ol> <li>Open Eclipse and go to <code>Help</code> \u2192 <code>Install New Software</code>.</li> <li>Click <code>Add...</code> and enter: <ul> <li>Name: Epsilon</li> <li>Location: <code>https://download.eclipse.org/epsilon/updates/</code></li> </ul> </li> <li>Select all the Epsilon components needed and proceed with the installation.</li> <li>Restart Eclipse when prompted.</li> </ol>"},{"location":"caps_installation_guide/#final-verification","title":"Final Verification","text":"<p>After installation, verify that:</p> <ul> <li>Java 8 is installed (<code>java -version</code> In Command Prompt)</li> <li>Eclipse Modeling Tools launches without errors</li> <li>EMF, GMF Tooling, and Epsilon are installed under <code>Help</code> \u2192 <code>About Eclipse</code> \u2192 <code>Installation Details</code></li> </ul> <p>This completes the setup process. You are now ready to use Eclipse for modeling and development!</p>"},{"location":"cupcarbon_installation_guide/","title":"CupCarbon Installation Guide","text":""},{"location":"cupcarbon_installation_guide/#step-1-download-cupcarbon","title":"Step 1: Download CupCarbon","text":"<ul> <li>Go to: https://cupcarbon.com/download_klines.php</li> <li>Click the download link for your platform (Windows, Mac, or Linux)</li> </ul>"},{"location":"cupcarbon_installation_guide/#step-2-unzip-the-file","title":"Step 2: Unzip the file","text":"<ul> <li>On Windows: Right-click the downloaded ZIP file \u2192 \u201cExtract All\u201d</li> <li>On Mac: Double-click the ZIP file to unzip it automatically</li> </ul>"},{"location":"cupcarbon_installation_guide/#step-3-run-cupcarbonjar","title":"Step 3: Run <code>cupcarbon.jar</code>","text":"<ul> <li>Open the unzipped folder</li> <li>Double-click <code>cupcarbon.jar</code>     If it doesn\u2019t open:</li> <li>Open a terminal/command prompt</li> <li>Navigate to the folder with <code>cupcarbon.jar</code></li> <li> <p>Run:</p> <pre><code>java -jar cupcarbon.jar  \n</code></pre> </li> </ul> <p>(You need Java installed; if not, download it from https://www.oracle.com/java/technologies/javase-downloads.html</p>"},{"location":"downloads/","title":"Downloads","text":"<p>Here you can download the full documentation and other resources for offline use.</p>"},{"location":"downloads/#complete-tutorial","title":"Complete Tutorial","text":"<p>     Download Complete Tutorial PDF </p>"},{"location":"downloads/#tool-documentation","title":"Tool Documentation","text":""},{"location":"downloads/#caps-documentation","title":"CAPS Documentation","text":"<p>     Download CAPS Guide </p>"},{"location":"downloads/#cupcarbon-documentation","title":"CupCarbon Documentation","text":"<p>     Download CupCarbon Guide </p>"},{"location":"downloads/#code-examples","title":"Code Examples","text":"<p>The PDFs include comprehensive information on the respective tools covered in this documentation site.</p>"},{"location":"downloads/#caps-code-example","title":"CAPS Code Example","text":"<p>     Download CAPS Examples </p>"},{"location":"downloads/#pydevs-code-example","title":"PyDEVS Code Example","text":"<p>     Download PyDEVS Examples </p>"},{"location":"downloads/#cupcarbon-code-example","title":"CupCarbon Code Example","text":"<p>     Download CupCarbon Examples </p>"},{"location":"eclipse_caps_integration_guide/","title":"Eclipse CAPS Integration Guide","text":""},{"location":"eclipse_caps_integration_guide/#step-1-download-the-caps-project-files","title":"Step 1: Download the CAPS Project Files","text":"<ol> <li>Obtain the latest CAPS project archive (<code>CAPS.7z</code>) from the official repository or provided link: Download CAPS.7z</li> <li>Save the file to a preferred location (e.g., <code>C:\\CAPS</code>).</li> <li>Extract the contents of <code>CAPS.7z</code> using a tool like WinRAR, 7-Zip, or Windows Explorer.</li> <li>Ensure the extracted folder contains a <code>Packages</code> directory with the required Eclipse projects.</li> </ol>"},{"location":"eclipse_caps_integration_guide/#step-2-import-projects-into-eclipse","title":"Step 2: Import Projects into Eclipse","text":"<ol> <li>Open Eclipse.</li> <li>Navigate to <code>File</code> \u2192 <code>Import</code>.</li> <li>Select <code>General</code> \u2192 <code>Existing Projects into Workspace</code> and click <code>Next</code></li> <li>Click <code>Browse</code> and select the extracted <code>Packages</code> folder.</li> <li>Ensure all projects are selected in the list.</li> <li>Click <code>Finish</code> to import the projects into your workspace.</li> </ol>"},{"location":"eclipse_caps_integration_guide/#step-3-configure-the-workspace","title":"Step 3: Configure the Workspace","text":""},{"location":"eclipse_caps_integration_guide/#run-the-diagram-editor","title":"Run the Diagram Editor","text":"<ol> <li>In the <code>Project Explorer</code>, locate the project <code>org.eclipse.epsilon.eugenia.examples.friends.diagram</code>.</li> <li>Right-click on the project and select <code>Run As</code> \u2192 <code>Eclipse Application</code>.</li> <li>A new Eclipse instance will launch, allowing you to work with the modeling environment.</li> </ol> <p>At this point, the CAPS framework should be successfully imported and ready for use in Eclipse.</p>"},{"location":"essentials/","title":"Essentials","text":"<p>This covers a few of the essentials needed. For complete information, please refer to the CupCarbon\u00ae User Guide Version U-One 5.1.</p>"},{"location":"essentials/#cupcarbon-environment","title":"CupCarbon Environment","text":"<p>To execute CupCarbon (jar file), use the command window and go to the directory where the jar file is located.</p> <p>Then execute the following command:</p> <pre><code>java -jar CupCarbon.jar\n</code></pre> <p>In the case of the existence of a proxy, use the following command:</p> <pre><code>java -jar CupCarbon.jar proxy_host_name proxy_number_of_port\n</code></pre> <p>As shown in the Figure, the CupCarbon Graphical User Interface (GUI) is composed of the following five main</p> <p>parts:</p> <ol> <li>The map (in the center)</li> <li>The menu bar (on the top)</li> <li>The Toolbar (below the menu)</li> <li>The parameter menu (on the left)</li> <li>The state bar (at the bottom)</li> <li>The console (in version 5, the console is separated from the main interface)</li> </ol> <p></p>"},{"location":"essentials/#the-map","title":"The Map","text":"<p>- The map is the main object of the simulator CupCarbon. It is the part where the network and the objects of the project can be designed. The map can be changed according to the preference of the user or the way the information must be presented.</p> <p></p> <p>The simulation time is displayed on the top left part of the map. During simulation, this time is displayed in red color, and an additional red rectangle is drawn around the map to detect the simulation process (cf. Figure 3 (a)). In this part, other information about the messages is also displayed, including the number of sent, received, ACK, and lost messages. This part can be hidden and displayed using the ALT+D keys.</p> <p></p>"},{"location":"essentials/#the-toolbar","title":"The Toolbar","text":"<p>The toolbar of CupCarbon is used to access the main actions of CupCarbon.</p> <p></p> <p>It is composed of 7 parts that are:</p>"},{"location":"essentials/#project-part","title":"Project part","text":"<p>It allows creating a new project, opening the last project, opening a project, and saving a project.</p>"},{"location":"essentials/#add-object-part","title":"Add object part","text":"<p>It allows adding objects (Sensor node, Directional Sensor node, Base station, Gas, Weather, Mobile, Marker, random sensor nodes) on the map.</p> <p>Add Sensor Nodes: A sensor node is an object that can detect any digital event (motion event like mobiles), send and receive data. It can also be mobile. The visible parameters of a sensor node are: the radio range, the radio of the sensor unit, and the name. A sensor node has many parameters; it can contain many radio modules, a battery, and a sensing unit.</p> <p>In the center of the sensor node, we find the name S followed by its ID. For example, if its ID is equal to 4, then its name will be S4. In the right part of the name, we find a number situated between brackets, which is equal to [0] by default. This number represents the MY address of this sensor node. If a SenScript is assigned to it, it will be displayed in a gray color above its name. The print messages will be displayed in blue below their names.</p> <p></p> <p>A sensor node contains a sensing unit represented by a transparent white circle. The area's radius can be changed using the buttons \u2018(\u2019 for increasing the radius and '(\u2018 for decreasing the radius.</p> <p></p> <p>Add Mobiles: used to simulate mobiles. Markers are also used to create routes followed by mobiles. Each mobile must have its route. They are also used to generate digital events.</p> <p></p> <p>A mobile depends on its route (trajectory). This last one is created using markers, as it is explained in the next section, bellow, one needs just to select the route which will be followed by the mobile in the list of created routes from the field GPS file in the Device Parameters view</p> <p>Add Markers: used mainly to generate routes for mobiles (or mobile sensors). They are also used to generate sensor nodes, create new buildings, and indicate the area of generating buildings or random sensor nodes.</p> <p></p> <p>It is possible to generate routes either by drawing the route manually using the markers or by creating just two markers and clicking on the button Route From Markers in the Marker Parameters view. Then, each created route can be saved and added to the list of routes of the project. This procedure is explained above in the Marker Parameters view section. A list of buildings can be added in the area delimited by two markers. It is possible to draw a building by drawing the form using markers and then by typing on the key \u2018:\u2019.</p> <p></p>"},{"location":"essentials/#connections-part","title":"Connections part","text":"<p>It allows for drawing normal or radio propagation-based connections between sensor nodes. It also calculates the visibility of the radio of the sensor node by considering the buildings of a city.</p> <p></p>"},{"location":"essentials/#simulation-part","title":"Simulation part","text":"<p>It allows running the simulation, stopping the simulation, drawing the energy consumption function, open the SenScript window and to open the Natural Event generator.</p> <p></p> <p>Run Simulation: to start the simulation</p> <p>Stop Simulation: to stop the simulation</p> <p>Energy Consumption: to display the graph of the energy consumption for the selected sensor nodes once the simulation is finished. You must first check the box Results before running the simulation. Two kinds of graphs are possible. The first one shows the state of the battery for the simulation time, and the other one shows the consumption of a sensor for the simulation time.</p>"},{"location":"essentials/#magnetism-part","title":"Magnetism part","text":"<p>It allows to add objects in an (invisible) grid. It is recommanded to use the map (Mean gray cell background).</p>"},{"location":"essentials/#selection-part","title":"Selection part","text":"<p>It allows to select all, select all sensor nodes, select all markers, select sensor nodes/markers, deselect all, and to invert selection</p> <p>Credit: Content taken from CupCarbon\u00ae User Guide Version U-One 5.1</p>"},{"location":"essentials/#the-parameter-panel","title":"The parameter panel","text":""},{"location":"essentials/#network-information-panel","title":"Network information panel","text":"<p>This panel shows some information about the network, like the number of sensors, the number of marked sensors, the number of isolated sensors, etc.</p> <p></p>"},{"location":"essentials/#devices-objects-device-list-selection-panel","title":"Devices &amp; Objects [Device List] [Selection] panel","text":"<p>This panel has two tabs. The first one is Device List, which allows you to select an object on the map by its name. The second one is the Selection tab that allows you to select/deselect objects by their type. It is also possible to select objects by their MY addresses or their IDs. These addresses/IDs can be entered as a list of numbers in the corresponding text field.</p> <p></p>"},{"location":"essentials/#device-parameters-panel","title":"Device Parameters panel","text":"<p>This panel allows you to modify the parameters of the selected objects, like:</p> <ol> <li>Script file: to assign the SenScript file</li> <li>GPS File: to assign the route file</li> <li>Natural Event File: to assign the natural event file generated from the Natural Event generator</li> <li>Id: to assign an ID</li> <li>Longitude: to assign a longitude</li> <li>Latitude: to assign a latitude</li> <li>Elevation: to assign an elevation</li> <li>Radius: to assign a radius for the sensor node (this is not the radio radius)</li> <li>Sensor Radius: to assign a radius for the sensing unit</li> <li>Energy max: the initial energy of the battery</li> <li>Sensing consumption: the sensing consumption in units (it is not considered in this version of CupCarbon)</li> <li>UART Datarate: the UART datarate, which represents the necessary time to send data (bytes) to the buffer of the radio module.</li> <li>Drift (sigma): the clock drift.</li> <li>The coverage of a sensing unit (case of directional sensor node)</li> <li>The direction (rotation) of a sensing unit (case of directional sensor node)</li> </ol> <p>Any modification is considered only if it is followed by a click on the apply button with the right gray arrow situated in the right part of the corresponding field.</p>"},{"location":"essentials/#radio-parameters-panel","title":"Radio Parameters panel","text":"<p>This panel allows for modifying the parameters of the radio module of the selected sensor nodes. From this, we mainly use Radius: the radius range of the selected radio module. In the propagation mode (when clicking on the icon of the state bar) is activated than this radius is calculated automatically depending on the signal propagation and the environment.</p>"},{"location":"essentials/#marker-parameters-panel","title":"Marker Parameters panel","text":"<p>This panel allows for working with the markers as follows:</p> <p>1. Route from markers: This button allows you to generate a route situated between two points of the map that are determined by two markers. If there are more than 2 markers, only the last two will be considered. This allows for drawing new routes as a continuation of the existing one.</p> <p></p> <p>2. Insert Markers: allows to insertion of markers after the selected ones (cf. Section Markers). The same result can be obtained by pressing the key \u2018u\u2019.</p>"},{"location":"essentials/#simulation-parameters-and-senscript-panel","title":"Simulation Parameters and SenScript Panel","text":"<p>This panel is used for the simulation. It contains the following buttons and options:</p> <p>SenScript: to open the SenScript window</p> <p>Simulation time: the duration of the simulation</p> <p>Simulation Speed: is the speed of the simulation. The objective of this button is to be able to follow and to visualize the simulation at human speed. It is useful for debugging.</p> <p>Arrow speed: the same as the Speed function, where the delay in this option is related to the sending/receiving message. It allows for to visualization of the messages.</p> <p>Run simulation: start the simulation (can also be done by pressing on Entree)</p> <p>Stop Simulation: stop the simulation</p>"},{"location":"hardware_modeling_language_%28hwml%29_guide/","title":"Hardware Modeling Language (HWML) Guide","text":""},{"location":"hardware_modeling_language_%28hwml%29_guide/#introduction-to-hwml","title":"Introduction to HWML","text":"<p>The Hardware Modeling Language (HWML) is a framework designed to model the hardware components of a system. It allows users to define deployment nodes, microcontrollers, processors, memory, energy sources, and various sensors. This guide provides a detailed step-by-step process for modeling hardware using HWML.</p>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-1-creating-a-new-hwml-model","title":"Step 1: Creating a New HWML Model","text":"<ol> <li>Open Eclipse and navigate to <code>Project Explorer</code>.</li> <li>Right-click on the <code>model</code> folder.</li> <li>Select <code>New</code> \u2192 <code>Other</code>.</li> <li>In the dialog box, search for CAPShwml Model.</li> <li>Click <code>Next</code>, then provide a name for the model (ensure it ends with <code>.capshwml</code>).</li> <li>Click <code>Next</code> again and choose Node Specification.</li> <li>Click <code>Finish</code> to create the HWML model file.</li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-2-initializing-the-hwml-diagram","title":"Step 2: Initializing the HWML Diagram","text":"<ol> <li>Locate the newly created <code>.capshwml</code> file in the <code>Project Explorer</code>.</li> <li>Right-click the file and select <code>Initialize Filesystem Diagram</code>.</li> <li>Enter a name for the diagram or keep the default name.</li> <li>Click <code>Finish</code> to generate the diagram workspace.</li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#defining-hardware-components","title":"Defining Hardware Components","text":""},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-3-creating-a-deployment-node","title":"Step 3: Creating a Deployment Node","text":"<ol> <li>Open the <code>Palette</code> view on the right-hand side of Eclipse.</li> <li>Select the Node element and place it onto the canvas.</li> <li>In the <code>Properties</code> view, set the following attributes: <ul> <li>Mac Protocol: ZIGBEE (standard communication protocol)</li> <li>Name: Occupancy Sensor</li> <li>OS: TinyOS (embedded operating system for wireless devices)</li> <li>Routing Protocol: GEAR (Geographical Energy Aware Routing)</li> </ul> </li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-4-adding-a-microcontroller","title":"Step 4: Adding a Microcontroller","text":"<ol> <li>From the<code>Palette</code>, select Microcontroller.</li> <li>Place it inside the previously created Node.</li> <li>This represents the microcontroller managing the sensor and data processing.</li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-5-adding-a-processor","title":"Step 5: Adding a Processor","text":"<ol> <li>Select Processor from the <code>Palette</code>.</li> <li>Place it inside the Microcontroller.</li> <li>Set the following attributes in the <code>Properties</code> view: <ul> <li>CPI (Clocks Per Instruction): 1.0</li> <li>Frequency: 120 MHz</li> <li>Name: Atmel Atmega328</li> </ul> </li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-6-adding-volatile-memory-ram","title":"Step 6: Adding Volatile Memory (RAM)","text":"<ol> <li>Select Volatile Memory from the <code>Palette</code>.</li> <li>Place it inside the Microcontroller.</li> <li>Set the following properties: <ul> <li>Name: RAM</li> <li>Size: 2 KB</li> </ul> </li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-7-adding-an-energy-source","title":"Step 7: Adding an Energy Source","text":"<ol> <li>Select Continuous Energy Source from the <code>Palette</code>.</li> <li>Place it inside the Node.</li> <li>Set the Name to <code>Electricity</code> (indicating a continuous power source).</li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-8-adding-a-sensor","title":"Step 8: Adding a Sensor","text":"<ol> <li>Select Occupancy Sensor from the <code>Palette</code>.</li> <li>Place it inside the Node to model the actual occupancy-sensing component.</li> </ol> <p>Final Diagram:</p> <p></p>"},{"location":"pydevs_motion_light_system/","title":"PyDEVS Motion Light System","text":"<p>This project implements a motion-activated lighting system using the Parallel DEVS (Discrete Event System Specification) formalism through PyDEVS.</p>"},{"location":"pydevs_motion_light_system/#system-overview","title":"System Overview","text":"<p>The system simulates a smart lighting setup where motion sensors trigger lights through a routing component. It demonstrates the principles of discrete event simulation with loosely coupled components communicating through well-defined interfaces.</p>"},{"location":"pydevs_motion_light_system/#file-structure-and-concepts","title":"File Structure and Concepts","text":""},{"location":"pydevs_motion_light_system/#modelpy","title":"<code>model.py</code>","text":"<p>This file defines the top-level coupled DEVS model (<code>GeneratedModel</code>) that composes the entire simulation. In DEVS formalism, a coupled model contains:</p> <ul> <li>Components (atomic or coupled models)</li> <li>Input and output ports</li> <li>Coupling relationships between components</li> </ul> <p>The <code>GeneratedModel</code> class instantiates the motion sensor, router, and light components, then establishes the connections between them to form the complete system topology.</p>"},{"location":"pydevs_motion_light_system/#motionsensorpy","title":"<code>motionsensor.py</code>","text":"<p>This file implements the <code>MotionSensor</code> atomic DEVS model that simulates a physical motion sensor. Key concepts:</p> <ul> <li><code>MotionSensorState</code>: Maintains the state variables for the sensor component</li> <li><code>MotionSensor</code>: Implements the DEVS atomic model with:</li> <li><code>__init__</code>: Sets up the sensor with its name, initial state, and ports</li> <li><code>timeAdvance</code>: Determines when the next internal transition will occur</li> <li><code>outputFnc</code>: Generates output events when motion is detected (randomly produces 0 or 1)</li> <li><code>intTransition</code>: Updates the component's state after an internal transition</li> <li><code>extTransition</code>: Handles external events (input messages from other components)</li> </ul> <p>The motion sensor generates randomized detection events (0 or 1) that are sent to the router component through its output port.</p>"},{"location":"pydevs_motion_light_system/#routerpy","title":"<code>router.py</code>","text":"<p>This file implements the <code>Router</code> atomic DEVS model that processes and routes messages between components. Key concepts:</p> <ul> <li><code>RouterState</code>: Maintains the state variables for the router component</li> <li><code>Router</code>: Implements DEVS functions for routing messages:</li> <li>Routes messages from the motion sensor to the appropriate light</li> <li>Acts as a middleware component that can implement filtering or transformation logic</li> <li>Follows DEVS protocol with timeAdvance, outputFnc, intTransition, and extTransition functions</li> </ul> <p>The router demonstrates the concept of message passing and decoupling in event-based architectures.</p>"},{"location":"pydevs_motion_light_system/#lightpy","title":"<code>light.py</code>","text":"<p>This file implements the <code>Light</code> atomic DEVS model that represents a physical light that turns on and off based on motion sensor input. Key concepts:</p> <ul> <li><code>LightState</code>: Maintains the state variables for the light component</li> <li><code>Light</code>: Implements the DEVS atomic model:</li> <li>Accepts input from the router</li> <li>Changes state based on the motion detection value</li> <li>Simulates the behavior of a light (on/off) based on sensor readings</li> <li>Implements timeouts to turn off after a period of no motion</li> </ul> <p>The light component shows how output devices respond to events in a discrete event system.</p>"},{"location":"pydevs_motion_light_system/#simulatepy","title":"<code>simulate.py</code>","text":"<p>This file contains the simulation execution code. Key concepts:</p> <ul> <li>Creates an instance of the <code>GeneratedModel</code></li> <li>Configures the PyDEVS simulator with parameters:</li> <li>Termination time (how long to run the simulation)</li> <li>DEVS formalism type (classic DEVS)</li> <li>Verbosity settings</li> <li>Redirects output to a log file</li> <li>Executes the simulation via <code>sim.simulate()</code></li> </ul> <p>This file demonstrates how to set up and run a discrete event simulation using the PyDEVS library.</p>"},{"location":"pydevs_motion_light_system/#stylecss","title":"<code>style.css</code>","text":"<p>This file contains the styling for the web-based visualization of the system. It defines:</p> <ul> <li>Layout of the visualization interface</li> <li>Styling of components and connections</li> <li>Interactive elements for the visualization dashboard</li> </ul> <p>The CSS supports the visualization aspect of the simulation, helping users understand the system structure and behavior.</p>"},{"location":"pydevs_motion_light_system/#devs-conceptual-framework","title":"DEVS Conceptual Framework","text":"<p>The system follows the DEVS formalism which includes:</p> <ol> <li>State-Based Modeling: Components maintain states that change over time</li> <li>Event-Driven Execution: System advances based on events rather than fixed time steps</li> <li>Hierarchical Composition: Simple models are combined to create complex systems</li> <li>Well-Defined Interfaces: Components interact only through input/output ports</li> <li>Time Advance Function: Each component determines when its next internal event occurs</li> </ol>"},{"location":"pydevs_motion_light_system/#simulation-flow","title":"Simulation Flow","text":"<ol> <li>The motion sensor periodically generates motion detection events (0 or 1)</li> <li>These events are sent to the router component</li> <li>The router forwards the events to the appropriate light component</li> <li>The light changes its state (on/off) based on the received values</li> <li>The simulation continues until the specified termination time is reached</li> </ol>"},{"location":"pythonpdevs_installation_guide/","title":"PythonPDEVS Installation Guide","text":"<ol> <li> <p>Prerequisites</p> <ul> <li>Make sure you have Python 3.x installed.</li> <li>You may need pip (Python package manager).</li> <li>Better to create virtual environment</li> <li>Clone the repository Open your terminal or command prompt and run:</li> </ul> <p>For Python 3.6 and earlier <pre><code>git clone https://github.com/capocchi/PythonPDEVS.git\n</code></pre></p> <p>For Python 3.7 and later: <pre><code>git clone https://github.com/likhithkanigolla/PyPDEVS-Updated.git\n</code></pre></p> </li> <li> <p>Navigate to the project directory</p> <p><pre><code>cd PythonPDEVS\n</code></pre> 4. Install PythonPDEVS Run the following command to install it using <code>setup.py</code>:</p> <pre><code>python setup.py install\n</code></pre> <p>Alternatively, if you prefer installing in development mode (helpful if you plan to modify the source):</p> <pre><code>python setup.py develop\n</code></pre> </li> </ol>"},{"location":"pythonpdevs_introduction/","title":"PythonPDEVS Introduction","text":"<p>PythonPDEVS is a Python implementation of the Parallel Discrete Event System Specification (PDEVS) formalism. It provides tools to model and simulate systems as a combination of atomic and coupled models, enabling hierarchical and modular system design.</p> <p>Atomic Models:</p> <ul> <li>The basic building blocks of a DEVS system.</li> <li>Define state variables, internal and external transitions, output functions, and time advance functions.</li> <li>Handle input and output events independently.</li> <li>Each atomic model simulates the behavior of a single component.</li> </ul> <p>Coupled Models:</p> <ul> <li>Allow combining multiple atomic models (or other coupled models) into a larger system.</li> <li>Define the connections (couplings) between submodels.</li> <li>Provide hierarchical composition, enabling complex systems to be built from simpler components.</li> <li>Do not define behavior themselves, but manage the structure and communication of submodels.</li> </ul> <p>In PythonPDEVS, you build a system by first creating atomic models (with logic and state changes), then integrating them into a coupled model to define how they interact and exchange events.</p>"},{"location":"research/","title":"Publications","text":"<p>Below are publications related to our work. </p>"},{"location":"research/#featured-publications","title":"Featured Publications","text":"<ol> <li>Architecting Digital Twin for Smart City Systems: A Case Study -  Likhith Kanigolla; Gaurav Pal; Karthik Vaidhyanathan; Deepak Gangadharan; Anuradha Vattem,21st International Conference on Software Architecture Workshops (ICSAW), 2024</li> <li>Modeling and Simulating IoT Infrastructures - Philipp Zech, Karthik Vaidhyanathan, Likhith Kanigolla, Luca Rahm, and Ruth Breu, 15th International Conference on Simulation and Modeling Methodologies, Technologies and Applications (SIMULTECH), 2025</li> </ol>"},{"location":"research/#alternative-download-link","title":"Alternative Download Link","text":"<p>You can also download the  Architecting Digital Twin for Smart City Systems PDF directly.</p>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/","title":"SAML (Software Architecture Modeling Language) Guide","text":""},{"location":"saml_%28software_architecture_modeling_language%29_guide/#overview","title":"Overview","text":"<p>SAML (Software Architecture Modeling Language) is used to model and simulate software architectures, particularly in IoT-based scenarios. It allows users to define components, interactions, and behaviors in a structured manner. This guide provides a step-by-step approach to using SAML for designing a temperature sensor-based automation system.</p>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#caps-environment-in-eclipse","title":"CAPS Environment in Eclipse","text":"<ol> <li>Folder Viewer (on the left)</li> <li>Diagram Canvas (in the center)</li> <li>Pallate(on the right)</li> <li>Connections(on the right)</li> <li>Properties Panel(at the bottom)</li> </ol>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#folder-viewer","title":"Folder Viewer","text":"<p>This displays the file structure. It contains your SAML project, and there is a folder called \u2018model\u2019 where you can create your SAML models.</p>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#diagram-canvas","title":"Diagram Canvas","text":"<p>Items can be taken from the palette and connections to model our SAML.</p> <p></p>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#pallate","title":"Pallate","text":"<p>Pallate contains all the components required for the architecture, such as sensors, timers etc</p> <p></p>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#connections","title":"Connections","text":"<p>Types of connections between the components can be selected from here.</p> <p></p>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#properties","title":"Properties","text":"<p>Configure the properties of the components used for modelling,</p> <p></p>"},{"location":"saml_for_motion_based_lighting_system/","title":"SAML for Motion Based Lighting System","text":""},{"location":"saml_for_motion_based_lighting_system/#project-description","title":"Project Description","text":"<p>This project implements an automated motion detection and response system using a sensor-controller-actuator architecture. A motion sensor continuously monitors for movement within its detection range. Upon detecting motion, the sensor transmits a signal to a controller (or router) responsible for processing the incoming data. The controller analyzes the signal and, based on predefined logic, sends a command to a light actuator to turn the light on. This system enables responsive, energy-efficient lighting by automating illumination based on occupancy or movement detection, making it ideal for smart home or smart building applications.</p>"},{"location":"saml_for_motion_based_lighting_system/#motion-sensor","title":"Motion Sensor","text":"<ol> <li>Detects Motion every second</li> <li>Sends the data to the controller/router</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#controllerrouter","title":"Controller/Router","text":"<ol> <li>Waits for the message to receive</li> <li>Look for the available nodes/lights</li> <li>Sends the message</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#sensorlight","title":"Sensor/Light","text":"<ol> <li>Receives the message.</li> <li>checks if it's 1 or 0.</li> <li>Turn on/off the light based on the condition.</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#steps-to-create-a-saml-project","title":"Steps to Create a SAML Project","text":""},{"location":"saml_for_motion_based_lighting_system/#1-create-a-new-saml-project","title":"1. Create a New SAML Project","text":"<ol> <li>Open Eclipse and go to <code>File</code> \u2192 <code>New</code> \u2192 <code>Project</code>.</li> <li>Select <code>EMF</code> \u2192 <code>Empty EMF Project</code>.</li> <li>Name the project and select a location (keeping the default workspace location is recommended).</li> <li>Click <code>Finish</code>.</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#2-create-the-saml-model-file","title":"2. Create the SAML Model File","text":"<ol> <li>In the Project Explorer, expand the newly created project.</li> <li>Right-click on the <code>model</code> folder, select <code>New</code> \u2192 <code>Other</code>.</li> <li>Search for <code>CAPSModel</code> and select <code>CAPSSaml</code>.</li> <li>Name the file, ensuring it ends with <code>.capssaml</code></li> <li>Click <code>Next</code>, select <code>Software Architecture</code> from the model object list, and click <code>Finish</code>.</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#3-initialize-the-diagram","title":"3. Initialize the Diagram","text":"<ol> <li>In the Project Explorer, right-click on the new <code>.capssaml</code> file.</li> <li>Select <code>Initialize friends diagram file</code>.</li> <li>Keep the default name and location, and click <code>Finish</code>.</li> <li>The diagram editor will open with an empty canvas.</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#4-creating-components","title":"4. Creating Components","text":"<p>1. Motion Sensor:</p> <ul> <li>From the palette, select <code>Component</code> and place it on the canvas.</li> <li>In the Properties view, name it <code>MotionSensor</code>.</li> <li>Inside the component, add: <ul> <li><code>Initial Mode</code> (to define its starting behavior).</li> <li><code>StartTimer</code> (to trigger periodic temperature readings).</li> <li><code>SenseOccupancy</code> (to simulate temperature sensing).</li> <li><code>TimerFired</code> (to handle the timer expiration event).</li> <li><code>UnicastSendMessage</code> (to send the motion data).</li> <li></li> </ul> </li> <li>Connect these elements using <code>Behavior Link</code>.</li> <li>Set StartTimer Properties: <ul> <li><code>Cyclic</code> \u2192 <code>True</code></li> <li><code>Name</code> \u2192 <code>MotionTimer</code></li> <li><code>Period</code> \u2192 <code>1000</code> (milliseconds, i.e., every 1 second)</li> </ul> </li> <li>Define <code>Primitive Data Declaration</code>: <ul> <li><code>Name</code> \u2192 <code>MotionData</code></li> <li><code>Type</code> \u2192 <code>Boolean</code></li> <li><code>Value</code> \u2192 <code>0</code></li> </ul> </li> <li>``</li> <li> <p>Select the <code>SenseOccupancy</code> item and, in the properties view, set the following parameters.</p> <ul> <li>Data Recipient \u2192Double click and select the Motion Data</li> <li> <p>Name \u2192SenseMotion</p> <p> - Select the message item and set the following parameters:      - Data \u2192MotionData;     - Data Recipient \u2192Select the Primitive Data Declaration MotionData variable;     - Name \u2192MotionValue </p> </li> </ul> </li> </ul> <p>Now add one OutMessagePort and connect the send MotionValue to the outport using the Send Message Port. You will see something similar to this at this moment:</p> <p></p> <p>2. Controller/Router</p> <ul> <li>Create a <code>Component</code> named <code>Controller</code>.</li> <li>Inside, add: <ul> <li><code>Initial Mode</code></li> <li><code>ReceiveMessage</code> (to get motion data from the sensor)</li> <li><code>Choice</code> (to implement decision-making logic)</li> <li>Two <code>UnicastSendMessage</code> instances (to send <code>On</code> or <code>Off</code> commands)</li> </ul> </li> <li>Define <code>Primitive Data Declaration</code>: <ul> <li><code>Name</code> \u2192 <code>Off</code>, <code>Type</code> \u2192 <code>Boolean</code>, <code>Value</code> \u2192 <code>False</code></li> <li><code>Name</code> \u2192 <code>On</code>, <code>Type</code> \u2192 <code>Boolean</code>, <code>Value</code> \u2192 <code>True</code></li> </ul> </li> <li>Select the message item and set the following parameters for one: <ul> <li>Data \u2192Off;</li> <li>Data Recipient \u2192Select the Primitive Data Declaration Off</li> <li>Name \u2192SendOff</li> </ul> </li> <li>Select the message item and set the following parameters for second: <ul> <li>Data \u2192On;</li> <li>Data Recipient \u2192Select the Primitive Data Declaration On</li> <li>Name \u2192SendOn</li> </ul> </li> <li>Connect elements with <code>Behavior Link</code>: <ul> <li><code>ReceiveMessage</code> \u2192 <code>Choice</code></li> <li><code>Choice</code> \u2192 <code>SendOnMessage</code> (if motion==1)</li> <li><code>Choice</code> \u2192 <code>SendOffMessage</code> (if motion==0)</li> </ul> </li> <li>Add the InMessagePort, connect to the Receive MotionValue using the ReceiveMessage Port, and 2 OutMessagePorts, and connect them to the UniCastSendMessage</li> </ul> <p></p> <p>3.Sensor/Light</p> <ul> <li>Create a <code>Component</code> named <code>Light</code>.</li> <li> <ul> <li>Inside, add:          - <code>Initial Mode</code>         - Two <code>ReceiveMessage</code> instances (one for <code>On</code>, one for <code>Off</code>)         - <code>Actuate</code> (to control the window mechanism)</li> <li>Connect elements with <code>Behavior Link</code>: <ul> <li><code>ReceiveOpenMessage</code> \u2192 <code>Actuate</code> (if 1 = True)</li> <li><code>ReceiveCloseMessage</code> \u2192 <code>Actuate</code> (if 0 = False)</li> </ul> </li> </ul> </li> <li>Now add two InMessagePorts and connect them to the two ReciveMessage using the ReceiveMessagePort</li> </ul> <p>4. Final Connections</p> <ul> <li>Use <code>OutMessagePort</code> and <code>InMessagePort</code> to link using the Connection <ul> <li>MotionSensor -&gt; Router</li> <li>Router(SendOn) to Light(ReceiveOn)</li> <li>Router(SendOff) to Light(ReceiveOff)</li> </ul> </li> </ul> <p>Final Diagram:</p> <p></p> <p>Save it and now, open the File in VSCode or in any code editor to see the XML file generated.</p>"},{"location":"simulate_motion_based_lighting_system_in_cup_carbon/","title":"Simulate Motion Based Lighting System in Cup Carbon","text":"<p>Open the CupCarbon and create the project:</p> <p></p> <p>Now, go to the map and select the Notebook view:</p> <p></p> <p></p> <p>Feel free to explore and select the other views as well.</p> <p>Now, let\u2019s create the base path using markers. From the toolbar, select the icon with the sky-blue circle and an arrow, or you can also use the shortcut key number 8. Now you can see the + icon start clicking and draw the path, once you are done right click the mouse.</p> <p>. </p> <p>Once you get a base shape, it\u2019s time to add more markers. These act as steps in the simulation, so the mobile node travels one dot per the given arrow speed. To start, click on the marker and keep pressing 'u'.</p> <p>.  </p> <p>Add as many markers as you need, you can draw any shape, or you can choose map view and draw to points and click Route From Markers from the Marker Parameters section in the slide bar.</p> <p>.  </p> <p>Save the markers drawn as the route from the side menu.</p> <p></p> <p>Now, it\u2019s time to add some sensor nodes. We will be using a total of three types: sensor node, IoT node, and mobile node. We will create two types within the sensor node: one for the controller and one for the sensor. to add the sensor node click on the purple circle from the toolbar or use the shortcut key '1'.</p> <p>Let's now go deeper and make this a sensor node that is supposed to detect the activity. As this sensor will be placed on the path, we created the inner circle should be on the points of the so we will reduce the radius to 20 and then also will keep the radio radius 20. Because keeping this bigger causes the other nearby sensors to be connected. We want the lights to be turned on only when the user is at that point. The same process will be followed for the controller/router. The difference between the sensor and the controller/router is sensor takes the readings, and the controller will forward the readings to the nearby nodes.</p> <p></p> <p>To make it alive, we need logic. So, click on the SenScript Window and add the code for both the sensor and the controller.</p> <p></p> <p>First, we will add the sensor code:</p> <pre><code>atget id id\nloop\ndreadsensor x\ndata message id x\nsend message 0 2\ndelay 1000\n</code></pre> <ul> <li>atget id id \u2192 id = id, my or ch of the sensor node</li> <li>loop \u2192 Starting the loop section</li> <li>dreadsensor x \u2192 x=1 if the sensor detects an event (mobile), x=0, otherwise</li> <li>data message id x \u2192 This line prepares a data message to be sent. It packages the data gathered from the sensor (<code>x</code> is the data being read), and associates it with the ID of the node (<code>id</code>). This message will be sent to another node or system.</li> <li>send message 0 2 \u2192 This sends the message from the sensor node to all nodes within its range. The ID of the node is set to 2 (this should be configured in the panel for the controller node). By doing this, we can broadcast the message to all nodes within range. If we hardcode the ID for each node, we would have to manually change it for every single node, which is inefficient. Broadcasting the message allows for dynamic communication across the network.</li> <li>delay 1000 \u2192 This introduces a delay of 1000 milliseconds (1 second).</li> </ul> <p>and save it with the extension csc.</p> <p>For the controller/router node:</p> <pre><code>atget id id\nloop\nwait \nread message\nrdata message rid x\ndata message2 id x\nsend message2 * rid\n</code></pre> <ul> <li>atget id id \u2192 id = id, my or ch of the sensor node</li> <li>loop \u2192 Starting the loop section</li> <li>wait \u2192 wait for the message</li> <li>read message \u2192 reads the message sent</li> <li> <p>rdata message rid x\u2192 This command extracts data from the received message (stored in <code>message</code>).     The message is assumed to be a string formatted with fields separated by <code>#</code>.</p> <ul> <li>It splits the message into parts.</li> <li>The first part is assigned to <code>rid</code> (the sender\u2019s ID).</li> <li>The second part is assigned to <code>x</code> (the data payload).</li> <li>data message2 id x\u2192This line prepares a data message to be sent. It packages the data gathered from the sensor</li> <li>send message2 * rid\u2192 Sends <code>message2</code> to all nodes in range of <code>rid</code> (the original sender). The <code>*</code> indicates broadcasting to all nodes within range of <code>rid</code>.</li> </ul> </li> </ul> <p>Finally, we will write the logic for the reciving node(IoT node):</p> <pre><code>loop \nwait \nread message\nrdata message rid x\n\nif(x==1)\n    print \"Detected\"\n    mark 1\nelse\n    print \"Not Detected\"\n    mark 0\nend\n</code></pre> <ul> <li>loop \u2192 Starting the loop section</li> <li>wait \u2192 wait for the message</li> <li>read message \u2192 reads the message sent</li> <li> <p>rdata message rid x\u2192 This command extracts data from the received message (stored in <code>message</code>).     The message is assumed to be a string formatted with fields separated by <code>#</code>.</p> <ul> <li>It splits the message into parts.</li> <li>The first part is assigned to <code>rid</code> (the sender\u2019s ID).</li> <li>The second part is assigned to <code>x</code> (the data payload).</li> <li>if condition \u2192 This condition checks if the value received is 1 or not, if 1 it prints Detected and turn on the node else prints Not Detected and keeps the node off or turn the node off.</li> </ul> </li> </ul> <p>After adding the one more node and a IoT node(This can be added using the bulb icon in the toolbar), the screen looks like this:</p> <p></p> <p>Arrows will be automatically added as the nodes are with in the range of the radio of the IoT node by default. now we have to assign the scripts to the nodes to make bring our model to the life.</p> <p>Now i will assign the sensor script to the node id S1 and the router script to the S3(this can be any node number) and to the IOT node my final receving script, to do this i will click on the node and then go to the Device Parameters section and select the respective script file.</p> <p></p> <p></p> <p></p> <p>Make sure you also set the MY value in the Radio Parameter to 2 for router node only. After Assigning screen looks like this, confirm that scripts are loaded. The name of the loaded script will be shown in the side. we now add the mobile node and assign the gps file only to it(the orange dot indicates the gps file is added to it).</p> <p></p> <p>Now its time to run the simulation. Click on the main simulation button, once started then to make the mobile node running go to the Simulation Parameters and run the simulation. Also, ensure that the router is connected to the sensor, if not move it close.</p> <p></p> <p> </p> <p>Now lets add more routers, lights and check our dynamic code logic.</p> <p></p> <p>Now i multplied the router nodes keeping the single sensor node and all the bulbs are conncected to the router nodes, so whenever there is a moment at the sensor node all the bulbs will get turned on. From the sensor the information will be sent to the bulbs through the routers.</p> <p></p> <p></p> <p></p> <p>To make this more intresting, we can multiple the sensor nodes and the router nodes where the one sensor node will send the information to only one router and the router will send the information to the nearby bulbs, This simulates the motion based lighting. Here is the complete example:</p> <p></p> <p>Hiding all the details, it will look like this</p> <p></p> <p>During Simulation:</p> <p></p> <p></p> <p>All the redlines indicate the data flow between the nodes. Now the whenever the mobile node is detected it will send the information to the router and the router sends to the nearby bulbs on command.</p> <p>The cup carbon code files for the shown example can be found at: https://github.com/likhithkanigolla/IIITS-Demo/tree/main/FinalCupCarbon-Demo</p>"},{"location":"code_examples/","title":"Code Examples Overview","text":"<p>This section contains code examples for various IoT modeling and digital twin implementation technologies covered in this documentation.</p>"},{"location":"code_examples/#available-examples","title":"Available Examples","text":""},{"location":"code_examples/#caps-model-examples","title":"CAPS Model Examples","text":"<p>CAPS Code Examples - Model-based IoT system design using CAPS.</p> <p>Download: CAPS Code Examples (ZIP)</p> <p>These examples demonstrate how to use the CAPS (Capabilities-based Architecture Platform for Smart-devices) modeling language for IoT system design:</p> <ul> <li>Hardware modeling with CAPSHWML</li> <li>Software architecture modeling with CAPSSAML</li> <li>Deployment mapping models</li> <li>Network configuration specifications</li> </ul>"},{"location":"code_examples/#cupcarbon-examples","title":"CupCarbon Examples","text":"<p>CupCarbon Code Examples - Wireless Sensor Network simulation using CupCarbon.</p> <p>Download: CupCarbon Code Examples (ZIP)</p> <p>These examples show how to create and simulate Wireless Sensor Networks (WSNs) using the CupCarbon simulator, including:</p> <ul> <li>Router node scripts for message forwarding</li> <li>Motion detector sensor scripts</li> <li>Light control actuator scripts</li> <li>Temperature monitoring scripts</li> <li>Gateway node configurations</li> <li>Hardware and radio configurations</li> <li>GPS movement path definitions</li> </ul>"},{"location":"code_examples/#pydevs-examples","title":"PyDEVS Examples","text":"<p>PyDEVS Code Examples - Discrete event simulation using PyDEVS for IoT systems.</p> <p>Download: PyDEVS Code Examples (ZIP)</p> <p>These examples demonstrate how to build discrete event simulations for IoT systems using the Python DEVS (Discrete Event System Specification) framework. They include:</p> <ul> <li>Motion sensor simulation</li> <li>Message routing components</li> <li>Light control actuator</li> <li>Complete system model integration</li> <li>Simulation execution and analysis</li> </ul>"},{"location":"code_examples/caps_code_examples/","title":"CAPS Code Examples","text":"<p>This page provides examples for using the CAPS (Capabilities-based Architecture Platform for Smart-devices) modeling language for IoT system design.</p> <p>Download: CAPS Code Examples (ZIP)</p>"},{"location":"code_examples/caps_code_examples/#example-categories","title":"Example Categories","text":""},{"location":"code_examples/caps_code_examples/#hardware-modeling-with-capshwml","title":"Hardware Modeling with CAPSHWML","text":"<p>These examples demonstrate how to model hardware components using CAPSHWML:</p>"},{"location":"code_examples/caps_code_examples/#overview-of-caps","title":"Overview of CAPS","text":"<p>CAPS is a model-based approach for designing IoT systems. It uses XML-based model files to define:</p> <ol> <li>Hardware components and their capabilities</li> <li>Software architectures and service interfaces</li> <li>Network configurations and protocols</li> <li>System behaviors and interactions</li> </ol> <p>The primary benefit of using CAPS is the ability to model an IoT system at a high level of abstraction before implementation.</p> <p>Note: You dont have to write these files, this will be generated automatically using the diagram panel from the eclipse as shown in the tutorial. </p>"},{"location":"code_examples/caps_code_examples/#hardware-modeling-with-capshwml_1","title":"Hardware Modeling with CAPSHWML","text":"<p>CAPSHWML (CAPS Hardware Modeling Language) is used to define the hardware components of an IoT system. These models specify sensors, actuators, processors, memory, and energy sources.</p>"},{"location":"code_examples/caps_code_examples/#motion-based-lighting-system-hardware-model","title":"Motion-Based Lighting System Hardware Model","text":"<p>The following example defines a hardware model for a motion-based lighting system.</p>"},{"location":"code_examples/caps_code_examples/#motionlightcapshwml","title":"MotionLight.capshwml","text":"<p>This file defines the hardware specification for an occupancy sensor node.</p> <pre><code>&lt;!-- Gist of MotionLight.capshwml --&gt;\n&lt;NodeSpecification&gt;\n  &lt;nodes name=\"Occupancy Sensor\" OS=\"TinyOS\" macProtocol=\"ZIGBEE\" routingProtocol=\"GEAR\"&gt;\n    &lt;energySources type=\"ContinuousEnergySource\" name=\"Electricity\"/&gt;\n    &lt;OccupancySensors name=\"OccupancySensor\"/&gt;\n    &lt;microcontroller&gt;\n      &lt;processors name=\"Atmel Atmega328\" frequency=\"120\" cpi=\"1.0\"/&gt;\n      &lt;memory name=\"RAM\" size=\"2\"/&gt;\n    &lt;/microcontroller&gt;\n  &lt;/nodes&gt;\n&lt;/NodeSpecification&gt;\n</code></pre>"},{"location":"code_examples/caps_code_examples/#key-components","title":"Key Components","text":"<ul> <li>Node Specification: Defines an \"Occupancy Sensor\" node with TinyOS operating system and ZIGBEE communication protocol</li> <li>Energy Source: Uses a continuous energy source (mains electricity)</li> <li>Sensors: Includes an occupancy sensor for motion detection</li> <li>Microcontroller: Specifies an Atmel Atmega328 processor with 120 MHz frequency and 2MB RAM</li> </ul>"},{"location":"code_examples/caps_code_examples/#software-architecture-with-capssaml","title":"Software Architecture with CAPSSAML","text":"<p>CAPSSAML (CAPS Software Architecture Modeling Language) defines the software architecture of an IoT system, including components, interfaces, and interactions.</p>"},{"location":"code_examples/caps_code_examples/#motion-based-lighting-system-software-model","title":"Motion-Based Lighting System Software Model","text":"<p>Note: This is not the complete file it just shows the syntax and the structure of the file. </p> <pre><code>&lt;!-- Gist of MotionLight.capssaml --&gt;\n&lt;SoftwareArchitecture&gt;\n  &lt;components name=\"Motion Detection\"&gt;\n    &lt;provides interface=\"SensorReading\" type=\"boolean\"/&gt;\n  &lt;/components&gt;\n  &lt;components name=\"Light Controller\"&gt;\n    &lt;requires interface=\"SensorReading\" type=\"boolean\"/&gt;\n    &lt;provides interface=\"LightControl\" type=\"command\"/&gt;\n  &lt;/components&gt;\n  &lt;components name=\"Light Actuator\"&gt;\n    &lt;requires interface=\"LightControl\" type=\"command\"/&gt;\n  &lt;/components&gt;\n  &lt;connections source=\"Motion Detection\" target=\"Light Controller\" interface=\"SensorReading\"/&gt;\n  &lt;connections source=\"Light Controller\" target=\"Light Actuator\" interface=\"LightControl\"/&gt;\n&lt;/SoftwareArchitecture&gt;\n</code></pre>"},{"location":"code_examples/caps_code_examples/#key-components_1","title":"Key Components","text":"<ul> <li>Motion Detection: Component that provides sensor readings</li> <li>Light Controller: Component that consumes sensor readings and provides light control commands</li> <li>Light Actuator: Component that consumes light control commands to operate the lights</li> <li>Connections: Defines how components interact through interfaces</li> </ul>"},{"location":"code_examples/caps_code_examples/#deployment-modeling-with-capsdeploy","title":"Deployment Modeling with CAPSDEPLOY","text":"<p>CAPSDEPLOY models define how software components are deployed onto hardware nodes.</p> <pre><code>&lt;!-- Gist of MotionLight.capsdeploy --&gt;\n&lt;Deployment&gt;\n  &lt;mapping component=\"Motion Detection\" node=\"Occupancy Sensor\"/&gt;\n  &lt;mapping component=\"Light Controller\" node=\"Gateway Node\"/&gt;\n  &lt;mapping component=\"Light Actuator\" node=\"Light Node\"/&gt;\n&lt;/Deployment&gt;\n</code></pre>"},{"location":"code_examples/caps_code_examples/#key-concepts","title":"Key Concepts","text":"<ul> <li>Mapping: Specifies which software components run on which hardware nodes</li> <li>The Motion Detection component is deployed on the Occupancy Sensor node</li> <li>The Light Controller runs on a gateway device</li> <li>The Light Actuator is deployed on a dedicated light control node</li> </ul>"},{"location":"code_examples/caps_code_examples/#network-configuration-with-capsnetwork","title":"Network Configuration with CAPSNETWORK","text":"<p>CAPSNETWORK models define the network configuration for the IoT system.</p> <pre><code>&lt;!-- Gist of MotionLight.capsnetwork --&gt;\n&lt;Network&gt;\n  &lt;topology type=\"Star\"&gt;\n    &lt;centralNode name=\"Gateway Node\"/&gt;\n    &lt;edgeNodes name=\"Occupancy Sensor\"/&gt;\n    &lt;edgeNodes name=\"Light Node\"/&gt;\n  &lt;/topology&gt;\n  &lt;protocol name=\"ZIGBEE\"&gt;\n    &lt;properties securityLevel=\"Medium\" dataRate=\"250kbps\"/&gt;\n  &lt;/protocol&gt;\n&lt;/Network&gt;\n</code></pre>"},{"location":"code_examples/caps_code_examples/#key-features","title":"Key Features","text":"<ul> <li>Topology: Defines a star network with a central gateway node</li> <li>Protocol: Specifies ZIGBEE communication with medium security level and 250kbps data rate</li> <li>Nodes: Lists all nodes participating in the network</li> </ul>"},{"location":"code_examples/caps_code_examples/#how-to-use-caps-models","title":"How to Use CAPS Models","text":"<ol> <li>Design Phase:</li> <li>Create hardware models (.capshwml) to define physical devices</li> <li>Develop software architecture models (.capssaml) to define components</li> <li>Create deployment models (.capsdeploy) to map software to hardware</li> <li> <p>Define network configurations (.capsnetwork) for communication</p> </li> <li> <p>Analysis Phase:</p> </li> <li>Validate models for consistency and completeness</li> <li>Analyze power consumption based on hardware specifications</li> <li>Verify network coverage and communication patterns</li> <li> <p>Check memory and processing requirements against hardware capabilities</p> </li> <li> <p>Implementation Phase:</p> </li> <li>Generate code stubs based on the models</li> <li>Implement component functionality according to interface specifications</li> <li>Deploy software following the deployment model</li> <li>Configure network according to network specifications</li> </ol>"},{"location":"code_examples/caps_code_examples/#benefits-of-model-based-design-with-caps","title":"Benefits of Model-Based Design with CAPS","text":"<ul> <li>Abstraction: Focus on system design without getting lost in implementation details</li> <li>Validation: Check system properties before implementation</li> <li>Reusability: Reuse models for similar IoT applications</li> <li>Documentation: Models serve as living documentation of the system</li> <li>Traceability: Maintain clear relationships between requirements and implementation</li> </ul> <p>These CAPS models provide a foundation for designing IoT systems in a structured and systematic way, ensuring that hardware capabilities, software functions, and network requirements are properly aligned.</p>"},{"location":"code_examples/cupcarbon_code_examples/","title":"CupCarbon Code Examples","text":"<p>This page provides examples for creating and simulating Wireless Sensor Networks (WSNs) using the CupCarbon simulator.</p> <p>Download: CupCarbon Code Examples (ZIP)</p>"},{"location":"code_examples/cupcarbon_code_examples/#example-categories","title":"Example Categories","text":""},{"location":"code_examples/cupcarbon_code_examples/#router-node-scripts","title":"Router Node Scripts","text":"<p>These examples demonstrate how to implement router node scripts for message forwarding:</p>"},{"location":"code_examples/cupcarbon_code_examples/#router-node-script-atget_routercsc","title":"Router Node Script (atget_router.csc)","text":"<p>This script creates a router node that forwards messages between sensor nodes. It's a fundamental component in a wireless sensor network simulation.</p>"},{"location":"code_examples/cupcarbon_code_examples/#code-breakdown","title":"Code Breakdown","text":"<pre><code>atget id id\nloop\nwait \nread message\nrdata message rid x\ndata message2 id x\nsend message2 * rid\n</code></pre>"},{"location":"code_examples/cupcarbon_code_examples/#explanation","title":"Explanation","text":"<ul> <li><code>atget id id</code>: Gets the node's own ID and stores it in the variable <code>id</code></li> <li><code>loop</code>: Starts an infinite loop for continuous operation</li> <li><code>wait</code>: Pauses the script until a message is received</li> <li><code>read message</code>: Reads the received message into the variable <code>message</code></li> <li><code>rdata message rid x</code>: Extracts data from the message - the sender ID (<code>rid</code>) and the payload (<code>x</code>)</li> <li><code>data message2 id x</code>: Creates a new message containing the router's ID and the original payload</li> <li><code>send message2 * rid</code>: Forwards the message to the node with ID matching <code>rid</code></li> </ul>"},{"location":"code_examples/cupcarbon_code_examples/#use-case","title":"Use Case","text":"<p>This router script is used to:</p> <ol> <li>Extend the range of a wireless sensor network</li> <li>Enable communication between nodes that are not within direct range of each other</li> <li>Create multi-hop network topologies for larger deployments</li> </ol>"},{"location":"code_examples/cupcarbon_code_examples/#motion-detector-script-motion_detectorcsc","title":"Motion Detector Script (motion_detector.csc)","text":"<p>This script implements a motion detector sensor that triggers when movement is detected in its vicinity.</p>"},{"location":"code_examples/cupcarbon_code_examples/#code-breakdown_1","title":"Code Breakdown","text":"<pre><code>atget id id\nloop\nareadsensor value\nif(value&gt;0)\n    data msg id value\n    send msg *\nend\ndelay 1000\n</code></pre>"},{"location":"code_examples/cupcarbon_code_examples/#explanation_1","title":"Explanation","text":"<ul> <li><code>atget id id</code>: Gets the node's own ID and stores it in the variable <code>id</code></li> <li><code>loop</code>: Starts an infinite loop for continuous monitoring</li> <li><code>areadsensor value</code>: Reads the analog sensor value (0 = no motion, &gt;0 = motion detected)</li> <li><code>if(value&gt;0)</code>: Checks if motion is detected</li> <li><code>data msg id value</code>: Creates a message with the node's ID and the sensor value</li> <li><code>send msg *</code>: Broadcasts the message to all nodes in range</li> <li><code>delay 1000</code>: Waits 1 second before checking for motion again</li> </ul>"},{"location":"code_examples/cupcarbon_code_examples/#use-case_1","title":"Use Case","text":"<p>This motion detector script is useful for:</p> <ol> <li>Security systems and intrusion detection</li> <li>Automatic lighting systems that activate when someone enters a room</li> <li>Occupancy monitoring in smart buildings</li> <li>Triggering cameras or other devices when motion is detected</li> </ol>"},{"location":"code_examples/cupcarbon_code_examples/#light-control-script-light_controlcsc","title":"Light Control Script (light_control.csc)","text":"<p>This script controls a light node based on messages received from motion sensors.</p>"},{"location":"code_examples/cupcarbon_code_examples/#code-breakdown_2","title":"Code Breakdown","text":"<pre><code>atget id id\nloop\nwait\nread msg\nrdata msg src value\nif(value&gt;0)\n    mark 1\n    delay 5000\n    mark 0\nend\n</code></pre>"},{"location":"code_examples/cupcarbon_code_examples/#explanation_2","title":"Explanation","text":"<ul> <li><code>atget id id</code>: Gets the node's own ID and stores it in the variable <code>id</code></li> <li><code>loop</code>: Starts an infinite loop to continuously check for messages</li> <li><code>wait</code>: Pauses the script until a message is received</li> <li><code>read msg</code>: Reads the received message into the variable <code>msg</code></li> <li><code>rdata msg src value</code>: Extracts the sender ID and sensor value from the message</li> <li><code>if(value&gt;0)</code>: Checks if the received value indicates motion</li> <li><code>mark 1</code>: Turns on the light (sets the node marker to 1)</li> <li><code>delay 5000</code>: Keeps the light on for 5 seconds</li> <li><code>mark 0</code>: Turns off the light (sets the node marker to 0)</li> </ul>"},{"location":"code_examples/cupcarbon_code_examples/#use-case_2","title":"Use Case","text":"<p>This light control script can be used to:</p> <ol> <li>Create energy-efficient lighting systems that only turn on when needed</li> <li>Simulate smart home lighting scenarios</li> <li>Test motion-based automation systems</li> <li>Demonstrate IoT device interaction in a network</li> </ol>"},{"location":"code_examples/cupcarbon_code_examples/#temperature-monitoring-script-temperature_monitorcsc","title":"Temperature Monitoring Script (temperature_monitor.csc)","text":"<p>This script monitors temperature and sends alerts when the temperature exceeds a threshold.</p>"},{"location":"code_examples/cupcarbon_code_examples/#code-breakdown_3","title":"Code Breakdown","text":"<pre><code>atget id id\nset threshold 25\nloop\n  sensing\n  areadsensor temp\n  if(temp &gt; threshold)\n    data tempAlert id temp\n    send tempAlert *\n  end\n  delay 5000\n</code></pre>"},{"location":"code_examples/cupcarbon_code_examples/#explanation_3","title":"Explanation","text":"<ul> <li><code>atget id id</code>: Gets the node's own ID and stores it in the variable <code>id</code></li> <li><code>set threshold 25</code>: Sets the temperature threshold to 25 degrees</li> <li><code>loop</code>: Starts an infinite loop for continuous monitoring</li> <li><code>sensing</code>: Activates the sensor to collect data</li> <li><code>areadsensor temp</code>: Reads the temperature value</li> <li><code>if(temp &gt; threshold)</code>: Checks if the temperature exceeds the defined threshold</li> <li><code>data tempAlert id temp</code>: Creates an alert message with the node ID and temperature</li> <li><code>send tempAlert *</code>: Broadcasts the alert to all nodes</li> <li><code>delay 5000</code>: Waits 5 seconds before the next temperature check</li> </ul>"},{"location":"code_examples/cupcarbon_code_examples/#use-case_3","title":"Use Case","text":"<p>This temperature monitoring script is suitable for:</p> <ol> <li>Environmental monitoring systems</li> <li>HVAC control in smart buildings</li> <li>Fire detection and prevention systems</li> <li>Agricultural monitoring for optimal growing conditions</li> </ol>"},{"location":"code_examples/cupcarbon_code_examples/#gateway-node-script-gatewaycsc","title":"Gateway Node Script (gateway.csc)","text":"<p>This script implements a gateway node that collects data from sensor nodes and can communicate with external systems.</p>"},{"location":"code_examples/cupcarbon_code_examples/#code-breakdown_4","title":"Code Breakdown","text":"<pre><code>atget id id\nloop\n  wait\n  read message\n  rdata message src data\n  data log id src data\n  printfile log.txt log\n  delay 100\n</code></pre>"},{"location":"code_examples/cupcarbon_code_examples/#explanation_4","title":"Explanation","text":"<ul> <li><code>atget id id</code>: Gets the node's own ID and stores it in the variable <code>id</code></li> <li><code>loop</code>: Starts an infinite loop for continuous operation</li> <li><code>wait</code>: Waits for incoming messages</li> <li><code>read message</code>: Reads the received message</li> <li><code>rdata message src data</code>: Extracts the sender ID and payload from the message</li> <li><code>data log id src data</code>: Creates a log entry with gateway ID, source ID, and the data</li> <li><code>printfile log.txt log</code>: Writes the log entry to a file named \"log.txt\"</li> <li><code>delay 100</code>: Brief pause before processing the next message</li> </ul>"},{"location":"code_examples/cupcarbon_code_examples/#use-case_4","title":"Use Case","text":"<p>This gateway script can be used for:</p> <ol> <li>Data collection from multiple sensors in an IoT network</li> <li>Creating a bridge between sensor networks and cloud platforms</li> <li>Logging sensor data for later analysis</li> <li>Monitoring the overall activity in a sensor network</li> </ol>"},{"location":"code_examples/cupcarbon_code_examples/#cupcarbon-configuration-files","title":"CupCarbon Configuration Files","text":"<p>CupCarbon uses several configuration files to define node properties, radio settings, and movement patterns. Below are examples and explanations of these configuration files.</p>"},{"location":"code_examples/cupcarbon_code_examples/#node-configuration-files","title":"Node Configuration Files","text":"<p>These files define the properties of different sensor nodes in the simulation.</p>"},{"location":"code_examples/cupcarbon_code_examples/#sensor-node-configuration-sensor","title":"Sensor Node Configuration (sensor)","text":"<pre><code>List of parameters\n------------------------------------------\ndevice_type:1\ndevice_id:402\ndevice_longitude:55.47531425209045\ndevice_latitude:25.303690903218275\ndevice_elevation:0.0\ndevice_radius:0.0\ndevice_hide:1\ndevice_pic:0\ndevice_draw_battery:false\ndevice_sensor_unit_radius:25.0\ndevice_script_file_name:atget_hello.csc\n</code></pre> <p>Explanation: - <code>device_type:1</code>: Indicates a standard sensor node - <code>device_id:402</code>: Unique identifier for this sensor - <code>device_longitude/latitude</code>: Geographic coordinates of the node - <code>device_elevation</code>: Height above ground level (0.0 = ground level) - <code>device_radius</code>: Physical radius of the node (0.0 = default size) - <code>device_hide:1</code>: Node visibility setting (1 = visible in simulation) - <code>device_draw_battery:false</code>: Whether to display battery status - <code>device_sensor_unit_radius:25.0</code>: Sensing range of the node - <code>device_script_file_name:atget_hello.csc</code>: Script that controls this node's behavior</p>"},{"location":"code_examples/cupcarbon_code_examples/#iot-device-configuration-iot","title":"IoT Device Configuration (iot)","text":"<pre><code>List of parameters\n------------------------------------------\ndevice_type:13\ndevice_id:200\ndevice_longitude:55.47740345516205\ndevice_latitude:25.30307910615224\ndevice_elevation:0.0\ndevice_radius:0.0\ndevice_hide:1\ndevice_draw_battery:false\ndevice_sensor_unit_radius:20.0\ndevice_pic:0\ndevice_script_file_name:atget_recive.csc\n</code></pre> <p>Explanation: - <code>device_type:13</code>: Indicates an IoT device node - <code>device_id:200</code>: Unique identifier for this IoT device - <code>device_sensor_unit_radius:20.0</code>: Sensing range (smaller than regular sensor) - <code>device_script_file_name:atget_recive.csc</code>: Script for receiving and processing data</p>"},{"location":"code_examples/cupcarbon_code_examples/#mobile-node-configuration-mobile","title":"Mobile Node Configuration (mobile)","text":"<pre><code>List of parameters\n------------------------------------------\ndevice_type:6\ndevice_id:35\ndevice_longitude:55.47770619392395\ndevice_latitude:25.303692700131606\ndevice_elevation:0.0\ndevice_radius:8.0\ndevice_hide:1\ndevice_gps_file_name:building.gps\n</code></pre> <p>Explanation: - <code>device_type:6</code>: Indicates a mobile node that can move - <code>device_id:35</code>: Unique identifier for this mobile node - <code>device_radius:8.0</code>: Larger radius to represent a moving object (e.g., vehicle) - <code>device_gps_file_name:building.gps</code>: GPS file that defines the movement path</p>"},{"location":"code_examples/cupcarbon_code_examples/#radio-configuration-files","title":"Radio Configuration Files","text":"<p>These files define the wireless communication capabilities of sensor nodes.</p>"},{"location":"code_examples/cupcarbon_code_examples/#standard-sensor-radio-configuration-sensor_radiossensor","title":"Standard Sensor Radio Configuration (sensor_radios/sensor)","text":"<pre><code>List of radio Modules for the Sensor402\n------------------------------------------\ncurrent_radio_name:radio1\nradio_standard:ZIGBEE\nradio_my:0\nradio_channel:0\nradio_network_id:13108\nradio_radius:30.0\nradio_etx:5.92E-5\nradio_erx:2.86E-5\nradio_esleep:1.0E-7\nradio_elisten:1.0E-6\nradio_data_rate:250000\nconso_tx_model:Classical (Tx)\nconso_rx_model:Classical (Rx)\n</code></pre> <p>Explanation: - <code>radio_standard:ZIGBEE</code>: Using ZigBee protocol for communication - <code>radio_radius:30.0</code>: Maximum communication range in meters - <code>radio_network_id:13108</code>: Network identifier for this radio - <code>radio_etx:5.92E-5</code>, <code>radio_erx:2.86E-5</code>: Energy consumption for transmitting/receiving - <code>radio_data_rate:250000</code>: Data transmission rate in bits per second</p>"},{"location":"code_examples/cupcarbon_code_examples/#iot-device-radio-configuration-sensor_radiosiot","title":"IoT Device Radio Configuration (sensor_radios/iot)","text":"<pre><code>List of radio Modules for the Sensor392\n------------------------------------------\ncurrent_radio_name:radio1\nradio_standard:ZIGBEE\nradio_my:0\nradio_channel:0\nradio_network_id:13108\nradio_radius:20.0\nradio_etx:5.92E-5\nradio_erx:2.86E-5\nradio_esleep:1.0E-7\nradio_elisten:1.0E-6\nradio_data_rate:250000\nconso_tx_model:Classical (Tx)\nconso_rx_model:Classical (Rx)\n</code></pre> <p>Explanation: - Similar to the standard sensor but with <code>radio_radius:20.0</code>: Shorter communication range - This creates a realistic scenario where IoT devices have more limited communication capabilities</p>"},{"location":"code_examples/cupcarbon_code_examples/#gps-movement-file-buildinggps","title":"GPS Movement File (building.gps)","text":"<p>GPS files define movement paths for mobile nodes. Below is a sample of the building.gps file:</p> <pre><code>Route name\nCity one\nCity two\nfalse\n10\n0 55.47838747501373 25.303067083442635 0.0 4.0\n1 55.47854874283075 25.303066780333015 0.0 4.0\n1 55.478710010647774 25.303066477223396 0.0 4.0\n// ...more path points...\n</code></pre> <p>Explanation: - First line: Route name - Second line: Starting location name - Third line: Destination name - Fourth line: Route visibility flag - Fifth line: Number of points in the route - Remaining lines: Path points in format <code>[type] [longitude] [latitude] [elevation] [speed]</code>   - Type 0 = starting point, Type 1 = path point   - Last two values define elevation and movement speed</p>"},{"location":"code_examples/cupcarbon_code_examples/#how-to-use-configuration-files","title":"How to Use Configuration Files","text":"<ol> <li>Node Configuration:</li> <li>Create nodes in CupCarbon by right-clicking on the map</li> <li>Configure properties through the node dialog or directly edit configuration files</li> <li> <p>Assign scripts to nodes by specifying the script filename</p> </li> <li> <p>Radio Configuration:</p> </li> <li>Access through the radio tab in node properties</li> <li>Adjust range and energy parameters based on your simulation requirements</li> <li> <p>Match network IDs for nodes that need to communicate</p> </li> <li> <p>GPS Movement:</p> </li> <li>Create paths by clicking on the map to place waypoints</li> <li>Save as GPS files for reuse</li> <li>Assign to mobile nodes through the node configuration</li> <li>Adjust speed values for realistic movement simulation</li> </ol> <p>These configuration files work together to create a realistic IoT simulation environment where: - Sensors collect and transmit data using their scripts - Radio configurations determine communication capabilities and energy consumption - Mobile nodes move along predefined paths to simulate dynamic environments</p>"},{"location":"code_examples/cupcarbon_code_examples/#complete-iot-simulation-setup","title":"Complete IoT Simulation Setup","text":"<p>A typical CupCarbon simulation combines the script files discussed earlier with appropriate configuration settings:</p> <ol> <li>Stationary sensors (using motion_detector.csc) placed at strategic locations</li> <li>Router nodes (using atget_router.csc) positioned to ensure network coverage</li> <li>Gateway node (using gateway.csc) collecting data from the network</li> <li>Mobile nodes following paths to simulate moving objects in the environment</li> </ol> <p>This creates a comprehensive IoT simulation that can model real-world applications like smart buildings, traffic monitoring, or environmental sensing.</p>"},{"location":"code_examples/cupcarbon_code_examples/#how-to-use-these-scripts","title":"How to Use These Scripts","text":"<ol> <li>Open CupCarbon simulation environment</li> <li>Create new sensor nodes for each script type needed</li> <li>Assign the appropriate script to each node</li> <li>Configure the network topology by placing nodes appropriately</li> <li>Run the simulation to observe the IoT network behavior</li> </ol>"},{"location":"code_examples/cupcarbon_code_examples/#additional-considerations","title":"Additional Considerations","text":"<ul> <li>Adjust thresholds and delay times based on your specific requirements</li> <li>For larger networks, use multiple router nodes to ensure proper message propagation</li> <li>Consider energy consumption by optimizing sensing and transmission frequencies</li> <li>Test your network under different conditions to ensure reliability</li> <li>Use the CupCarbon visualization tools to monitor network activity during simulation</li> </ul>"},{"location":"code_examples/pydevs_code_examples/","title":"PyDEVS Code Examples","text":"<p>This page provides examples for building discrete event simulations for IoT systems using the Python DEVS (Discrete Event System Specification) framework.</p> <p>Download: PyDEVS Code Examples (ZIP)</p>"},{"location":"code_examples/pydevs_code_examples/#example-categories","title":"Example Categories","text":""},{"location":"code_examples/pydevs_code_examples/#motion-sensor-simulation","title":"Motion Sensor Simulation","text":"<p>These examples demonstrate how to simulate motion sensors:</p>"},{"location":"code_examples/pydevs_code_examples/#motion-based-lighting-system","title":"Motion-Based Lighting System","text":"<p>This example demonstrates a motion-based lighting system using PyDEVS. The system consists of a motion sensor, a router (controller), and a light component.</p>"},{"location":"code_examples/pydevs_code_examples/#system-architecture","title":"System Architecture","text":"<p>The system consists of three main components:</p> <ol> <li>Motion Sensor: Generates motion detection events</li> <li>Router: Routes messages based on the motion state</li> <li>Light: Controls the light based on received commands</li> </ol> <p>These components are connected in a directed graph to form a complete motion-based lighting system.</p>"},{"location":"code_examples/pydevs_code_examples/#motion-sensor-component-motionsensorpy","title":"Motion Sensor Component (motionsensor.py)","text":"<p>This component simulates a motion sensor that periodically detects motion in its vicinity.</p>"},{"location":"code_examples/pydevs_code_examples/#code-breakdown","title":"Code Breakdown","text":"<pre><code>from pypdevs.DEVS import AtomicDEVS\nfrom pypdevs.infinity import INFINITY\nimport random\nimport time\n\nclass MotionSensorState:\n    def __init__(self):\n        self.MotionData = 0\n        self.MotionTimer_next = 0.0\n        self.data_to_send = None\n        self.output_port = None\n        self.received_value = None\n\n\nclass MotionSensor(AtomicDEVS):\n    def __init__(self, name=\"MotionSensor\", **kwargs):\n        AtomicDEVS.__init__(self, name)\n        self.state = MotionSensorState()\n        self.timeLast = 0.0\n\n        # Initialize ports\n        self.out_0 = self.addOutPort(\"out_0\")\n\n        # Initialize parameters\n        self.state.MotionData = kwargs.get('MotionData', 0)\n\n        # Initialize timers\n        self.state.MotionTimer_next = 1.0\n\n    def timeAdvance(self):\n        \"\"\"Return time until next internal transition\"\"\"\n                # Check if there's data to send immediately\n        if self.state.data_to_send is not None:\n            return 0.0\n\n        next_time = INFINITY\n        if hasattr(self.state, 'MotionTimer_next'):\n            next_time = min(next_time, self.state.MotionTimer_next - self.timeLast)\n        return next_time\n\n    def intTransition(self):\n        \"\"\"Handle internal transition\"\"\"\n        if hasattr(self.state, 'MotionTimer_next') and self.state.MotionTimer_next &lt;= self.timeLast:\n            self.state.MotionTimer_next = self.timeLast + 1.0\n        self.state.data_to_send = None\n        return self.state\n\n    def extTransition(self, inputs):\n        \"\"\"Handle external transition\"\"\"\n        print(f\"extTransition called\")\n        return self.state\n\n    def outputFnc(self):\n        \"\"\"Generate output\"\"\"\n        result = {}\n        # Generate sensor data\n        sensor_data = {\n            \"m2m:cin\": {\n                \"lbl\": [\n                    f\"{self.name}\"\n                ],\n                \"con\": f\"{self.name}, {int(time.time())}, {random.randint(0, 1)}\"\n            }\n        }\n        # Send to all output ports\n        for port_name in dir(self):\n            if port_name.startswith('out_'):\n                port = getattr(self, port_name)\n                result[port] = sensor_data\n        return result\n\n    def __lt__(self, other):\n        \"\"\"Comparison method required for sorting during simulation\"\"\"\n        return self.name &lt; other.name\n</code></pre>"},{"location":"code_examples/pydevs_code_examples/#explanation","title":"Explanation","text":"<ul> <li>MotionSensorState: Maintains the state of the motion sensor</li> <li><code>MotionData</code>: Current motion value (0 or 1)</li> <li> <p><code>MotionTimer_next</code>: Tracks when the next motion check should occur</p> </li> <li> <p>MotionSensor Class: Implements the behavior of a motion sensor</p> </li> <li><code>timeAdvance()</code>: Determines when the next internal transition should occur</li> <li><code>intTransition()</code>: Updates the state after an internal transition</li> <li><code>outputFnc()</code>: Generates random motion detection events (0 or 1)</li> <li>The sensor generates data in the oneM2M format, a standard for IoT communication</li> </ul>"},{"location":"code_examples/pydevs_code_examples/#router-component-routerpy","title":"Router Component (router.py)","text":"<p>This component routes messages based on motion sensor data.</p>"},{"location":"code_examples/pydevs_code_examples/#code-breakdown_1","title":"Code Breakdown","text":"<pre><code>from pypdevs.DEVS import AtomicDEVS\nfrom pypdevs.infinity import INFINITY\nimport random\nimport time\n\nclass RouterState:\n    def __init__(self):\n        self.Off = False\n        self.On = True\n        self.data_to_send = None\n        self.output_port = None\n        self.motion = None  # Condition variable from model\n\nclass Router(AtomicDEVS):\n    def __init__(self, name=\"Router\", **kwargs):\n        AtomicDEVS.__init__(self, name)\n        self.state = RouterState()\n        self.timeLast = 0.0\n\n        # Initialize ports\n        self.in_0 = self.addInPort(\"in_0\")\n        self.out_0 = self.addOutPort(\"out_0\")\n        self.out_1 = self.addOutPort(\"out_1\")\n\n        # Initialize parameters\n        self.state.Off = kwargs.get('Off', False)\n        self.state.On = kwargs.get('On', True)\n\n    def timeAdvance(self):\n        \"\"\"Return time until next internal transition\"\"\"\n        return INFINITY if self.state.data_to_send is None else 0.0\n\n    def intTransition(self):\n        \"\"\"Handle internal transition\"\"\"\n        self.state.data_to_send = None\n        self.state.output_port = None\n        return self.state\n\n    def extTransition(self, inputs):\n        \"\"\"Handle external transition\"\"\"\n        received_data = None\n        for port_name, port_value in inputs.items():\n            received_data = port_value\n\n        # Process data for controller\n        if received_data is not None:\n            # Extract data from received message\n            if isinstance(received_data, dict) and 'm2m:cin' in received_data:\n                content = received_data['m2m:cin'].get('con', '')\n                parts = content.split(',')\n                if len(parts) &gt; 2:\n                    try:\n                        # Extract value from the message\n                        value = float(parts[2].strip())\n                        self.state.motion = value  # Store in condition variable\n\n                        # Apply model-defined conditions\n                        if value == 0:\n                            self.state.motion = True\n                            self.state.data_to_send = received_data\n                            self.state.output_port = \"out_1\"\n                        elif value == 1:\n                            self.state.motion = True\n                            self.state.data_to_send = received_data\n                            self.state.output_port = \"out_1\"\n                        else:\n                            # No condition matched\n                            self.state.data_to_send = None\n                            print(f\"[{self.name}] Value {value} is in normal range: No action\")\n                    except (ValueError, IndexError):\n                        print(\"Error parsing value\")\n        return self.state\n\n    def outputFnc(self):\n        \"\"\"Generate output\"\"\"\n        result = {}\n        if hasattr(self.state, 'data_to_send') and self.state.data_to_send is not None and self.state.output_port:\n            port = getattr(self, self.state.output_port)\n            result[port] = self.state.data_to_send\n        return result\n\n    def __lt__(self, other):\n        \"\"\"Comparison method required for sorting during simulation\"\"\"\n        return self.name &lt; other.name\n</code></pre>"},{"location":"code_examples/pydevs_code_examples/#explanation_1","title":"Explanation","text":"<ul> <li>RouterState: Maintains the state of the router</li> <li><code>data_to_send</code>: Data to be forwarded</li> <li><code>output_port</code>: Selected output port based on logic</li> <li> <p><code>motion</code>: Current motion state</p> </li> <li> <p>Router Class: Implements message routing logic</p> </li> <li><code>extTransition()</code>: Processes incoming messages and determines routing</li> <li>Parses oneM2M formatted messages to extract sensor values</li> <li>Routes messages to different outputs based on motion values (0 or 1)</li> </ul>"},{"location":"code_examples/pydevs_code_examples/#model-component-modelpy","title":"Model Component (model.py)","text":"<p>This component defines the overall system model by connecting the components.</p>"},{"location":"code_examples/pydevs_code_examples/#code-breakdown_2","title":"Code Breakdown","text":"<pre><code>from pypdevs.DEVS import CoupledDEVS\nfrom motionsensor import MotionSensor\nfrom router import Router\nfrom light import Light\nclass GeneratedModel(CoupledDEVS):\n    def __init__(self):\n        CoupledDEVS.__init__(self, \"GeneratedModel\")\n        print(\"Model Loading...\")\n\n        # Initialize components\n        self.c1 = self.addSubModel(MotionSensor(\"c1\"))\n        print(\"Initialized MotionSensor as c1\")\n        self.c2 = self.addSubModel(Router(\"c2\"))\n        print(\"Initialized Router as c2\")\n        self.c3 = self.addSubModel(Light(\"c3\"))\n        print(\"Initialized Light as c3\")\n\n        # Connect components\n        self.connectPorts(self.c1.out_0, self.c2.in_0)\n        print(\"Connected c1.out_0 to c2.in_0\")\n        self.connectPorts(self.c2.out_0, self.c3.in_1)\n        print(\"Connected c2.out_0 to c3.in_1\")\n        self.connectPorts(self.c2.out_1, self.c3.in_0)\n        print(\"Connected c2.out_1 to c3.in_0\")\n\n        print(\"Model initialization complete\")\n</code></pre>"},{"location":"code_examples/pydevs_code_examples/#explanation_2","title":"Explanation","text":"<ul> <li>GeneratedModel Class: Creates a coupled model by connecting components</li> <li>Instantiates MotionSensor, Router, and Light components</li> <li>Connects component ports to define the system structure:<ul> <li>Motion sensor output connects to router input</li> <li>Router outputs connect to different light inputs for on/off control</li> </ul> </li> </ul>"},{"location":"code_examples/pydevs_code_examples/#simulation-runner-simulatepy","title":"Simulation Runner (simulate.py)","text":"<p>This component runs the simulation for the defined model.</p>"},{"location":"code_examples/pydevs_code_examples/#code-breakdown_3","title":"Code Breakdown","text":"<pre><code>import sys\nimport os\nimport random\nimport time\n\n# Add the current directory to the Python path\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\n\nfrom pypdevs.simulator import Simulator\nfrom model import GeneratedModel\n\n# Create the model\nmodel = GeneratedModel()\n\n# Create the simulator\nsim = Simulator(model)\n\n# Configure the simulation\nsim.setTerminationTime(1000.0)  # Run for 1000 time units\nsim.setClassicDEVS()  # Use classic DEVS formalism\n\n# Use the correct setVerbose syntax for your PyDEVS version\n# It expects either None or a string filename, not a boolean\nsim.setVerbose(None)  # No additional verbosity\n\n# Redirect stdout to capture log\nlog_file = 'simulation.log'\noriginal_stdout = sys.stdout\ntry:\n    with open(log_file, 'w') as f:\n        sys.stdout = f\n        # Run the simulation\n        sim.simulate()\nfinally:\n    # Restore stdout\n    sys.stdout = original_stdout\n\nprint(f\"Simulation complete. Results saved to {log_file}\")\n</code></pre>"},{"location":"code_examples/pydevs_code_examples/#explanation_3","title":"Explanation","text":"<ul> <li>Creates an instance of the GeneratedModel</li> <li>Configures the simulation parameters:</li> <li>Sets a termination time of 1000 time units</li> <li>Uses classic DEVS formalism</li> <li>Redirects output to a log file</li> <li>Runs the simulation and captures the results</li> </ul>"},{"location":"code_examples/pydevs_code_examples/#experiment-runner-experimentpy","title":"Experiment Runner (experiment.py)","text":"<p>This script provides a convenient way to run the simulation and examine the results.</p>"},{"location":"code_examples/pydevs_code_examples/#code-breakdown_4","title":"Code Breakdown","text":"<pre><code>import os\nimport subprocess\nimport sys\n\nprint(\"Running simulation...\")\n\n# Run the simulation\ntry:\n    # First try to run with python command\n    result = subprocess.run(['python', 'simulate.py'], capture_output=True, text=True)\n    if result.returncode != 0 and sys.executable:\n        # If that fails, try with the current Python interpreter\n        print(\"Trying with current Python executable...\")\n        result = subprocess.run([sys.executable, 'simulate.py'], capture_output=True, text=True)\nexcept Exception as e:\n    print(f\"Error running simulation: {e}\")\n    sys.exit(1)\n\n# Print output\nprint(\"\\nSimulation output:\")\nprint(result.stdout)\n\nif result.stderr:\n    print(\"\\nErrors:\")\n    print(result.stderr)\n\n# Open the log file\ntry:\n    with open('simulation.log', 'r') as f:\n        log_content = f.read()\n        print(\"\\nSimulation Log Preview (first 1000 chars):\")\n        print(log_content[:1000])\n        print(\"\\n...\\n\")\nexcept FileNotFoundError:\n    print(\"Simulation log file not found.\")\n\nprint(\"To view full log, open 'simulation.log'\")\n</code></pre>"},{"location":"code_examples/pydevs_code_examples/#explanation_4","title":"Explanation","text":"<ul> <li>Executes the simulation script as a subprocess</li> <li>Handles different Python interpreter paths for compatibility</li> <li>Displays simulation output and errors</li> <li>Provides a preview of the simulation log file</li> </ul>"},{"location":"code_examples/pydevs_code_examples/#how-to-run-the-simulation","title":"How to Run the Simulation","text":"<ol> <li>Make sure all Python files (motionsensor.py, router.py, light.py, model.py, simulate.py, experiment.py) are in the same directory</li> <li>Ensure PyDEVS is installed (you can install it with <code>pip install pypdevs</code>)</li> <li>Run the experiment script with <code>python experiment.py</code></li> <li>Review the output and simulation log file for results</li> </ol>"},{"location":"code_examples/pydevs_code_examples/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":"<ol> <li>Discrete Event Simulation: The system is modeled as a series of discrete events rather than continuous changes</li> <li>Component-Based Modeling: Each part of the system is modeled as a separate component</li> <li>Event Propagation: Events propagate through the system via connected ports</li> <li>State Machines: Each component implements a state machine with defined transitions</li> <li>IoT Communication Patterns: Uses oneM2M formatting to simulate IoT data exchange</li> </ol> <p>This example provides a foundation for modeling more complex IoT systems using PyDEVS, where you can add additional sensors, controllers, and actuators.</p>"}]}