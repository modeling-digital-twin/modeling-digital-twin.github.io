{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IoT Modelling for Digital Twins","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the IoT Modelling for Digital Twins documentation. This project focuses on creating comprehensive models for Internet of Things (IoT) systems that can be represented as digital twins in virtual environments.</p>"},{"location":"#what-are-digital-twins","title":"What are Digital Twins?","text":"<p>Digital twins are virtual representations of physical objects, processes, or systems that serve as the real-time digital counterparts of physical entities. In the IoT context, digital twins enable:</p> <ul> <li>Real-time monitoring and visualization</li> <li>Predictive analytics and simulation</li> <li>Enhanced decision-making capabilities</li> <li>Optimized performance and maintenance</li> </ul>"},{"location":"#what-is-caps","title":"What is CAPS?","text":"<p>The CAPS Modeling Framework was created to support the engineering of Situational Aware Cyber-Physical Systems (SiA-CPS). SiA-CPS are systems consisting of a set of IoT devices such as sensors, cameras, RFID, and other monitoring tools used to continuously observe given indoor and outdoor spaces. The data gathered during this process is then transformed into actionable insights.</p> <p>SiA-CPS systems require monitoring in both time and space, meaning they consist of:</p> <ul> <li>Software components (drivers and code running on the sensors)</li> <li>Hardware components (sensors, cameras, RFID, etc.)</li> <li>Environmental interactions (how software and hardware components interact with their surroundings)</li> </ul> <p>Designing such systems poses challenges in ensuring consistency between managing software, hardware, and environmental views. To address this, the CAPS Modeling Framework provides a multi-view approach based on the IEEE/ISO/IEC 42010 standard, ensuring structured and coherent system modeling.</p> <p>For more information, visit: https://caps.disim.univaq.it/</p>"},{"location":"#what-is-cupcarbon","title":"What is CupCarbon","text":"<p>CupCarbon is a comprehensive simulator designed for modeling, visualizing, and analyzing smart city and Internet of Things (IoT) wireless sensor networks (WSNs). It enables users to create and simulate networks directly on geographic maps, allowing realistic placement of nodes and environmental conditions. With support for static and mobile nodes, energy consumption modeling, routing, and communication protocols, CupCarbon provides a powerful environment for testing IoT applications before physical deployment.</p> <p>Researchers, educators, and developers use CupCarbon to experiment with network behaviors, evaluate communication strategies, and validate system architectures in simulated urban or rural environments. Its scripting language (Senscript) allows users to program node behaviors, making it highly customizable for a wide range of IoT and WSN projects.</p> <p>Learn more and download CupCarbon at: https://cupcarbon.com/</p>"},{"location":"#what-is-pdevs","title":"What is PDEVS?","text":"<p>Parallel Discrete Event System Specification (PDEVS) is an extension of the DEVS (Discrete Event System Specification) formalism, providing a structured approach to modeling and simulating complex discrete event systems. PDEVS enhances traditional DEVS by introducing parallel event handling, allowing multiple simultaneous events to be processed in a single simulation step. This improves efficiency and makes it suitable for simulating large-scale, interconnected systems.</p> <p>PDEVS models a system as a set of components (atomic and coupled models) that interact through well-defined input, output, and state transition functions. Each component responds to events over simulated time, enabling hierarchical, modular, and reusable system representations.</p> <p>PDEVS is widely used in fields such as IoT, smart cities, cyber-physical systems, logistics, and distributed systems to simulate dynamic, event-driven behaviors before implementation. It supports both theoretical analysis and practical software simulation frameworks like PyDEVS, MS4 Me, and DEVSJAVA.</p> <p>To learn more, visit: https://en.wikipedia.org/wiki/Discrete_Event_System_Specification</p> <p>https://msdl.uantwerpen.be/documentation/PythonPDEVS/</p>"},{"location":"about/","title":"About This Project","text":""},{"location":"about/#project-goals","title":"Project Goals","text":"<p>The IoT Modelling for Digital Twins project aims to:</p> <ol> <li>Provide comprehensive resources for creating digital twin models for IoT systems</li> <li>Establish best practices for integrating physical and digital worlds</li> <li>Accelerate development of digital twin solutions across industries</li> <li>Create a community of practitioners sharing knowledge and code</li> </ol>"},{"location":"about/#contributors","title":"Contributors","text":"<p>This documentation and the associated codebase are maintained by a team of IoT and digital twin enthusiasts. Key contributors include:</p> <ul> <li>Project Lead: [Your Name]</li> <li>IoT Architecture: [Contributor Name]</li> <li>Data Modeling: [Contributor Name]</li> <li>Simulation Systems: [Contributor Name]</li> </ul>"},{"location":"about/#get-involved","title":"Get Involved","text":"<p>We welcome contributions to this project! Here's how you can get involved:</p>"},{"location":"about/#report-issues","title":"Report Issues","text":"<p>Found a bug or have a suggestion? Open an issue on our GitHub repository.</p>"},{"location":"about/#contribute-code","title":"Contribute Code","text":"<ol> <li>Fork the repository</li> <li>Create your feature branch (<code>git checkout -b feature/amazing-feature</code>)</li> <li>Commit your changes (<code>git commit -m 'Add some amazing feature'</code>)</li> <li>Push to the branch (<code>git push origin feature/amazing-feature</code>)</li> <li>Open a Pull Request</li> </ol>"},{"location":"about/#improve-documentation","title":"Improve Documentation","text":"<p>Help us improve this documentation by suggesting changes or additions through pull requests.</p>"},{"location":"about/#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"about/#contact","title":"Contact","text":"<p>For questions or comments about this project, please contact us at:</p> <ul> <li>Email: contact@example.com</li> <li>Twitter: @YourTwitterHandle</li> <li>GitHub: GitHub Repository</li> </ul>"},{"location":"caps_installation_guide/","title":"CAPS Installation Guide","text":""},{"location":"caps_installation_guide/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding with the installation, ensure that your system meets the following requirements:</p> <ul> <li>Windows operating system (64-bit)(Tried on Windows expecting same will work for other systems as well)</li> <li>Internet connection</li> <li>Sufficient disk space (at least 5GB free)</li> </ul>"},{"location":"caps_installation_guide/#step-1-download-and-install-java-8","title":"Step 1: Download and Install Java 8","text":"<ol> <li>Visit the Java SE 8 Downloads page.</li> <li>Accept the license agreement and download the Windows x64 JRE.</li> <li>Run the installer and follow the on-screen instructions.</li> <li> <p>Verify the installation by opening the Command Prompt (<code>Win + R</code>, type <code>cmd</code>, and press Enter) and running: <code>sh     java -version</code></p> <p>Ensure it displays Java 1.8.</p> </li> </ol>"},{"location":"caps_installation_guide/#step-2-download-and-install-eclipse-modeling-tools","title":"Step 2: Download and Install Eclipse Modeling Tools","text":"<ol> <li>Visit the Eclipse download page.</li> <li>Download the Eclipse Installer for Windows (64-bit).</li> <li>Run the installer and select Advanced Mode. </li> <li>Choose Eclipse Modeling Tools as the package.</li> <li>Select the Product version as Photon and proceed with the installation and select the Java 1.8</li> <li>Once installed, launch Eclipse.</li> </ol>"},{"location":"caps_installation_guide/#step-3-install-emf","title":"Step 3: Install EMF","text":"<ol> <li>Open Eclipse and go to <code>Help</code> \u2192 <code>Install New Software</code>.</li> <li>In the Work with: field, select All Available Sites.</li> <li>Search for EMF - Eclipse Modeling Framework.</li> <li>Check the box for Eclipse Modeling Framework SDK and proceed with the installation.</li> <li>Restart Eclipse when prompted.</li> </ol>"},{"location":"caps_installation_guide/#step-4-install-gmf-tooling","title":"Step 4: Install GMF Tooling","text":"<ol> <li>Open Eclipse and navigate to <code>Help</code> \u2192 <code>Install New Software</code>.</li> <li>Click on <code>Add...</code> and enter the following: <ul> <li>Name: GMF Tooling</li> <li>Location: <code>https://download.eclipse.org/epsilon/updates/gmf-tooling/</code></li> </ul> </li> <li>Select GMF Tooling and click <code>Next</code>.</li> <li>Complete the installation and restart Eclipse.</li> </ol>"},{"location":"caps_installation_guide/#step-5-install-epsilon","title":"Step 5: Install Epsilon","text":"<ol> <li>Open Eclipse and go to <code>Help</code> \u2192 <code>Install New Software</code>.</li> <li>Click <code>Add...</code> and enter: <ul> <li>Name: Epsilon</li> <li>Location: <code>https://download.eclipse.org/epsilon/updates/</code></li> </ul> </li> <li>Select all the Epsilon components needed and proceed with the installation.</li> <li>Restart Eclipse when prompted.</li> </ol>"},{"location":"caps_installation_guide/#final-verification","title":"Final Verification","text":"<p>After installation, verify that:</p> <ul> <li>Java 8 is installed (<code>java -version</code> In Command Prompt)</li> <li>Eclipse Modeling Tools launches without errors</li> <li>EMF, GMF Tooling, and Epsilon are installed under <code>Help</code> \u2192 <code>About Eclipse</code> \u2192 <code>Installation Details</code></li> </ul> <p>This completes the setup process. You are now ready to use Eclipse for modeling and development!</p>"},{"location":"cupcarbon_installation_guide/","title":"CupCarbon Installation Guide","text":""},{"location":"cupcarbon_installation_guide/#step-1-download-cupcarbon","title":"Step 1: Download CupCarbon","text":"<ul> <li>Go to: https://cupcarbon.com/download_klines.php</li> <li>Click the download link for your platform (Windows, Mac, or Linux)</li> </ul>"},{"location":"cupcarbon_installation_guide/#step-2-unzip-the-file","title":"Step 2: Unzip the file","text":"<ul> <li>On Windows: Right-click the downloaded ZIP file \u2192 \u201cExtract All\u201d</li> <li>On Mac: Double-click the ZIP file to unzip it automatically</li> </ul>"},{"location":"cupcarbon_installation_guide/#step-3-run-cupcarbonjar","title":"Step 3: Run <code>cupcarbon.jar</code>","text":"<ul> <li>Open the unzipped folder</li> <li>Double-click <code>cupcarbon.jar</code>     If it doesn\u2019t open:</li> <li>Open a terminal/command prompt</li> <li>Navigate to the folder with <code>cupcarbon.jar</code></li> <li> <p>Run:</p> <pre><code>java -jar cupcarbon.jar  \n</code></pre> </li> </ul> <p>(You need Java installed; if not, download it from https://www.oracle.com/java/technologies/javase-downloads.html</p>"},{"location":"eclipse_caps_integration_guide/","title":"Eclipse CAPS Integration Guide","text":""},{"location":"eclipse_caps_integration_guide/#step-1-download-the-caps-project-files","title":"Step 1: Download the CAPS Project Files","text":"<ol> <li>Obtain the latest CAPS project archive (<code>CAPS.7z</code>) from the official repository or provided link: Download CAPS.7z</li> <li>Save the file to a preferred location (e.g., <code>C:\\CAPS</code>).</li> <li>Extract the contents of <code>CAPS.7z</code> using a tool like WinRAR, 7-Zip, or Windows Explorer.</li> <li>Ensure the extracted folder contains a <code>Packages</code> directory with the required Eclipse projects.</li> </ol>"},{"location":"eclipse_caps_integration_guide/#step-2-import-projects-into-eclipse","title":"Step 2: Import Projects into Eclipse","text":"<ol> <li>Open Eclipse.</li> <li>Navigate to <code>File</code> \u2192 <code>Import</code>.</li> <li>Select <code>General</code> \u2192 <code>Existing Projects into Workspace</code> and click <code>Next</code></li> <li>Click <code>Browse</code> and select the extracted <code>Packages</code> folder.</li> <li>Ensure all projects are selected in the list.</li> <li>Click <code>Finish</code> to import the projects into your workspace.</li> </ol>"},{"location":"eclipse_caps_integration_guide/#step-3-configure-the-workspace","title":"Step 3: Configure the Workspace","text":""},{"location":"eclipse_caps_integration_guide/#run-the-diagram-editor","title":"Run the Diagram Editor","text":"<ol> <li>In the <code>Project Explorer</code>, locate the project <code>org.eclipse.epsilon.eugenia.examples.friends.diagram</code>.</li> <li>Right-click on the project and select <code>Run As</code> \u2192 <code>Eclipse Application</code>.</li> <li>A new Eclipse instance will launch, allowing you to work with the modeling environment.</li> </ol> <p>At this point, the CAPS framework should be successfully imported and ready for use in Eclipse.</p>"},{"location":"essentials/","title":"Essentials","text":"<p>This covers a few of the essentials needed. For complete information, please refer to the CupCarbon\u00ae User Guide Version U-One 5.1.</p>"},{"location":"essentials/#cupcarbon-environment","title":"CupCarbon Environment","text":"<p>To execute CupCarbon (jar file), use the command window and go to the directory where the jar file is located.</p> <p>Then execute the following command:</p> <pre><code>java -jar CupCarbon.jar\n</code></pre> <p>In the case of the existence of a proxy, use the following command:</p> <pre><code>java -jar CupCarbon.jar proxy_host_name proxy_number_of_port\n</code></pre> <p>As shown in the Figure, the CupCarbon Graphical User Interface (GUI) is composed of the following five main</p> <p>parts:</p> <ol> <li>The map (in the center)</li> <li>The menu bar (on the top)</li> <li>The Toolbar (below the menu)</li> <li>The parameter menu (on the left)</li> <li>The state bar (at the bottom)</li> <li>The console (in version 5, the console is separated from the main interface)</li> </ol> <p></p>"},{"location":"essentials/#the-map","title":"The Map","text":"<p>- The map is the main object of the simulator CupCarbon. It is the part where the network and the objects of the project can be designed. The map can be changed according to the preference of the user or the way the information must be presented.</p> <p></p> <p>The simulation time is displayed on the top left part of the map. During simulation, this time is displayed in red color, and an additional red rectangle is drawn around the map to detect the simulation process (cf. Figure 3 (a)). In this part, other information about the messages is also displayed, including the number of sent, received, ACK, and lost messages. This part can be hidden and displayed using the ALT+D keys.</p> <p></p>"},{"location":"essentials/#the-toolbar","title":"The Toolbar","text":"<p>The toolbar of CupCarbon is used to access the main actions of CupCarbon.</p> <p></p> <p>It is composed of 7 parts that are:</p>"},{"location":"essentials/#project-part","title":"Project part","text":"<p>It allows creating a new project, opening the last project, opening a project, and saving a project.</p>"},{"location":"essentials/#add-object-part","title":"Add object part","text":"<p>It allows adding objects (Sensor node, Directional Sensor node, Base station, Gas, Weather, Mobile, Marker, random sensor nodes) on the map.</p> <p>Add Sensor Nodes: A sensor node is an object that can detect any digital event (motion event like mobiles), send and receive data. It can also be mobile. The visible parameters of a sensor node are: the radio range, the radio of the sensor unit, and the name. A sensor node has many parameters; it can contain many radio modules, a battery, and a sensing unit.</p> <p>In the center of the sensor node, we find the name S followed by its ID. For example, if its ID is equal to 4, then its name will be S4. In the right part of the name, we find a number situated between brackets, which is equal to [0] by default. This number represents the MY address of this sensor node. If a SenScript is assigned to it, it will be displayed in a gray color above its name. The print messages will be displayed in blue below their names.</p> <p></p> <p>A sensor node contains a sensing unit represented by a transparent white circle. The area's radius can be changed using the buttons \u2018(\u2019 for increasing the radius and '(\u2018 for decreasing the radius.</p> <p></p> <p>Add Mobiles: used to simulate mobiles. Markers are also used to create routes followed by mobiles. Each mobile must have its route. They are also used to generate digital events.</p> <p></p> <p>A mobile depends on its route (trajectory). This last one is created using markers, as it is explained in the next section, bellow, one needs just to select the route which will be followed by the mobile in the list of created routes from the field GPS file in the Device Parameters view</p> <p>Add Markers: used mainly to generate routes for mobiles (or mobile sensors). They are also used to generate sensor nodes, create new buildings, and indicate the area of generating buildings or random sensor nodes.</p> <p></p> <p>It is possible to generate routes either by drawing the route manually using the markers or by creating just two markers and clicking on the button Route From Markers in the Marker Parameters view. Then, each created route can be saved and added to the list of routes of the project. This procedure is explained above in the Marker Parameters view section. A list of buildings can be added in the area delimited by two markers. It is possible to draw a building by drawing the form using markers and then by typing on the key \u2018:\u2019.</p> <p></p>"},{"location":"essentials/#connections-part","title":"Connections part","text":"<p>It allows for drawing normal or radio propagation-based connections between sensor nodes. It also calculates the visibility of the radio of the sensor node by considering the buildings of a city.</p> <p></p>"},{"location":"essentials/#simulation-part","title":"Simulation part","text":"<p>It allows running the simulation, stopping the simulation, drawing the energy consumption function, open the SenScript window and to open the Natural Event generator.</p> <p></p> <p>Run Simulation: to start the simulation</p> <p>Stop Simulation: to stop the simulation</p> <p>Energy Consumption: to display the graph of the energy consumption for the selected sensor nodes once the simulation is finished. You must first check the box Results before running the simulation. Two kinds of graphs are possible. The first one shows the state of the battery for the simulation time, and the other one shows the consumption of a sensor for the simulation time.</p>"},{"location":"essentials/#magnetism-part","title":"Magnetism part","text":"<p>It allows to add objects in an (invisible) grid. It is recommanded to use the map (Mean gray cell background).</p>"},{"location":"essentials/#selection-part","title":"Selection part","text":"<p>It allows to select all, select all sensor nodes, select all markers, select sensor nodes/markers, deselect all, and to invert selection</p> <p>Credit: Content taken from CupCarbon\u00ae User Guide Version U-One 5.1</p>"},{"location":"essentials/#the-parameter-panel","title":"The parameter panel","text":""},{"location":"essentials/#network-information-panel","title":"Network information panel","text":"<p>This panel shows some information about the network, like the number of sensors, the number of marked sensors, the number of isolated sensors, etc.</p> <p></p>"},{"location":"essentials/#devices-objects-device-list-selection-panel","title":"Devices &amp; Objects [Device List] [Selection] panel","text":"<p>This panel has two tabs. The first one is Device List, which allows you to select an object on the map by its name. The second one is the Selection tab that allows you to select/deselect objects by their type. It is also possible to select objects by their MY addresses or their IDs. These addresses/IDs can be entered as a list of numbers in the corresponding text field.</p> <p></p>"},{"location":"essentials/#device-parameters-panel","title":"Device Parameters panel","text":"<p>This panel allows you to modify the parameters of the selected objects, like:</p> <ol> <li>Script file: to assign the SenScript file</li> <li>GPS File: to assign the route file</li> <li>Natural Event File: to assign the natural event file generated from the Natural Event generator</li> <li>Id: to assign an ID</li> <li>Longitude: to assign a longitude</li> <li>Latitude: to assign a latitude</li> <li>Elevation: to assign an elevation</li> <li>Radius: to assign a radius for the sensor node (this is not the radio radius)</li> <li>Sensor Radius: to assign a radius for the sensing unit</li> <li>Energy max: the initial energy of the battery</li> <li>Sensing consumption: the sensing consumption in units (it is not considered in this version of CupCarbon)</li> <li>UART Datarate: the UART datarate, which represents the necessary time to send data (bytes) to the buffer of the radio module.</li> <li>Drift (sigma): the clock drift.</li> <li>The coverage of a sensing unit (case of directional sensor node)</li> <li>The direction (rotation) of a sensing unit (case of directional sensor node)</li> </ol> <p>Any modification is considered only if it is followed by a click on the apply button with the right gray arrow situated in the right part of the corresponding field.</p>"},{"location":"essentials/#radio-parameters-panel","title":"Radio Parameters panel","text":"<p>This panel allows for modifying the parameters of the radio module of the selected sensor nodes. From this, we mainly use Radius: the radius range of the selected radio module. In the propagation mode (when clicking on the icon of the state bar) is activated than this radius is calculated automatically depending on the signal propagation and the environment.</p>"},{"location":"essentials/#marker-parameters-panel","title":"Marker Parameters panel","text":"<p>This panel allows for working with the markers as follows:</p> <p>1. Route from markers: This button allows you to generate a route situated between two points of the map that are determined by two markers. If there are more than 2 markers, only the last two will be considered. This allows for drawing new routes as a continuation of the existing one.</p> <p></p> <p>2. Insert Markers: allows to insertion of markers after the selected ones (cf. Section Markers). The same result can be obtained by pressing the key \u2018u\u2019.</p>"},{"location":"essentials/#simulation-parameters-and-senscript-panel","title":"Simulation Parameters and SenScript Panel","text":"<p>This panel is used for the simulation. It contains the following buttons and options:</p> <p>SenScript: to open the SenScript window</p> <p>Simulation time: the duration of the simulation</p> <p>Simulation Speed: is the speed of the simulation. The objective of this button is to be able to follow and to visualize the simulation at human speed. It is useful for debugging.</p> <p>Arrow speed: the same as the Speed function, where the delay in this option is related to the sending/receiving message. It allows for to visualization of the messages.</p> <p>Run simulation: start the simulation (can also be done by pressing on Entree)</p> <p>Stop Simulation: stop the simulation</p>"},{"location":"hardware_modeling_language_%28hwml%29_guide/","title":"Hardware Modeling Language (HWML) Guide","text":""},{"location":"hardware_modeling_language_%28hwml%29_guide/#introduction-to-hwml","title":"Introduction to HWML","text":"<p>The Hardware Modeling Language (HWML) is a framework designed to model the hardware components of a system. It allows users to define deployment nodes, microcontrollers, processors, memory, energy sources, and various sensors. This guide provides a detailed step-by-step process for modeling hardware using HWML.</p>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-1-creating-a-new-hwml-model","title":"Step 1: Creating a New HWML Model","text":"<ol> <li>Open Eclipse and navigate to <code>Project Explorer</code>.</li> <li>Right-click on the <code>model</code> folder.</li> <li>Select <code>New</code> \u2192 <code>Other</code>.</li> <li>In the dialog box, search for CAPShwml Model.</li> <li>Click <code>Next</code>, then provide a name for the model (ensure it ends with <code>.capshwml</code>).</li> <li>Click <code>Next</code> again and choose Node Specification.</li> <li>Click <code>Finish</code> to create the HWML model file.</li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-2-initializing-the-hwml-diagram","title":"Step 2: Initializing the HWML Diagram","text":"<ol> <li>Locate the newly created <code>.capshwml</code> file in the <code>Project Explorer</code>.</li> <li>Right-click the file and select <code>Initialize Filesystem Diagram</code>.</li> <li>Enter a name for the diagram or keep the default name.</li> <li>Click <code>Finish</code> to generate the diagram workspace.</li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#defining-hardware-components","title":"Defining Hardware Components","text":""},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-3-creating-a-deployment-node","title":"Step 3: Creating a Deployment Node","text":"<ol> <li>Open the <code>Palette</code> view on the right-hand side of Eclipse.</li> <li>Select the Node element and place it onto the canvas.</li> <li>In the <code>Properties</code> view, set the following attributes: <ul> <li>Mac Protocol: ZIGBEE (standard communication protocol)</li> <li>Name: Occupancy Sensor</li> <li>OS: TinyOS (embedded operating system for wireless devices)</li> <li>Routing Protocol: GEAR (Geographical Energy Aware Routing)</li> </ul> </li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-4-adding-a-microcontroller","title":"Step 4: Adding a Microcontroller","text":"<ol> <li>From the<code>Palette</code>, select Microcontroller.</li> <li>Place it inside the previously created Node.</li> <li>This represents the microcontroller managing the sensor and data processing.</li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-5-adding-a-processor","title":"Step 5: Adding a Processor","text":"<ol> <li>Select Processor from the <code>Palette</code>.</li> <li>Place it inside the Microcontroller.</li> <li>Set the following attributes in the <code>Properties</code> view: <ul> <li>CPI (Clocks Per Instruction): 1.0</li> <li>Frequency: 120 MHz</li> <li>Name: Atmel Atmega328</li> </ul> </li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-6-adding-volatile-memory-ram","title":"Step 6: Adding Volatile Memory (RAM)","text":"<ol> <li>Select Volatile Memory from the <code>Palette</code>.</li> <li>Place it inside the Microcontroller.</li> <li>Set the following properties: <ul> <li>Name: RAM</li> <li>Size: 2 KB</li> </ul> </li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-7-adding-an-energy-source","title":"Step 7: Adding an Energy Source","text":"<ol> <li>Select Continuous Energy Source from the <code>Palette</code>.</li> <li>Place it inside the Node.</li> <li>Set the Name to <code>Electricity</code> (indicating a continuous power source).</li> </ol>"},{"location":"hardware_modeling_language_%28hwml%29_guide/#step-8-adding-a-sensor","title":"Step 8: Adding a Sensor","text":"<ol> <li>Select Occupancy Sensor from the <code>Palette</code>.</li> <li>Place it inside the Node to model the actual occupancy-sensing component.</li> </ol> <p>Final Diagram:</p> <p></p>"},{"location":"hwml/","title":"HWML","text":""},{"location":"pydevs_motion_light_system/","title":"PyDEVS Motion Light System","text":"<p>This project implements a motion-activated lighting system using the Parallel DEVS (Discrete Event System Specification) formalism through PyDEVS.</p>"},{"location":"pydevs_motion_light_system/#system-overview","title":"System Overview","text":"<p>The system simulates a smart lighting setup where motion sensors trigger lights through a routing component. It demonstrates the principles of discrete event simulation with loosely coupled components communicating through well-defined interfaces.</p>"},{"location":"pydevs_motion_light_system/#file-structure-and-concepts","title":"File Structure and Concepts","text":""},{"location":"pydevs_motion_light_system/#modelpy","title":"<code>model.py</code>","text":"<p>This file defines the top-level coupled DEVS model (<code>GeneratedModel</code>) that composes the entire simulation. In DEVS formalism, a coupled model contains:</p> <ul> <li>Components (atomic or coupled models)</li> <li>Input and output ports</li> <li>Coupling relationships between components</li> </ul> <p>The <code>GeneratedModel</code> class instantiates the motion sensor, router, and light components, then establishes the connections between them to form the complete system topology.</p>"},{"location":"pydevs_motion_light_system/#motionsensorpy","title":"<code>motionsensor.py</code>","text":"<p>This file implements the <code>MotionSensor</code> atomic DEVS model that simulates a physical motion sensor. Key concepts:</p> <ul> <li><code>MotionSensorState</code>: Maintains the state variables for the sensor component</li> <li><code>MotionSensor</code>: Implements the DEVS atomic model with:</li> <li><code>__init__</code>: Sets up the sensor with its name, initial state, and ports</li> <li><code>timeAdvance</code>: Determines when the next internal transition will occur</li> <li><code>outputFnc</code>: Generates output events when motion is detected (randomly produces 0 or 1)</li> <li><code>intTransition</code>: Updates the component's state after an internal transition</li> <li><code>extTransition</code>: Handles external events (input messages from other components)</li> </ul> <p>The motion sensor generates randomized detection events (0 or 1) that are sent to the router component through its output port.</p>"},{"location":"pydevs_motion_light_system/#routerpy","title":"<code>router.py</code>","text":"<p>This file implements the <code>Router</code> atomic DEVS model that processes and routes messages between components. Key concepts:</p> <ul> <li><code>RouterState</code>: Maintains the state variables for the router component</li> <li><code>Router</code>: Implements DEVS functions for routing messages:</li> <li>Routes messages from the motion sensor to the appropriate light</li> <li>Acts as a middleware component that can implement filtering or transformation logic</li> <li>Follows DEVS protocol with timeAdvance, outputFnc, intTransition, and extTransition functions</li> </ul> <p>The router demonstrates the concept of message passing and decoupling in event-based architectures.</p>"},{"location":"pydevs_motion_light_system/#lightpy","title":"<code>light.py</code>","text":"<p>This file implements the <code>Light</code> atomic DEVS model that represents a physical light that turns on and off based on motion sensor input. Key concepts:</p> <ul> <li><code>LightState</code>: Maintains the state variables for the light component</li> <li><code>Light</code>: Implements the DEVS atomic model:</li> <li>Accepts input from the router</li> <li>Changes state based on the motion detection value</li> <li>Simulates the behavior of a light (on/off) based on sensor readings</li> <li>Implements timeouts to turn off after a period of no motion</li> </ul> <p>The light component shows how output devices respond to events in a discrete event system.</p>"},{"location":"pydevs_motion_light_system/#simulatepy","title":"<code>simulate.py</code>","text":"<p>This file contains the simulation execution code. Key concepts:</p> <ul> <li>Creates an instance of the <code>GeneratedModel</code></li> <li>Configures the PyDEVS simulator with parameters:</li> <li>Termination time (how long to run the simulation)</li> <li>DEVS formalism type (classic DEVS)</li> <li>Verbosity settings</li> <li>Redirects output to a log file</li> <li>Executes the simulation via <code>sim.simulate()</code></li> </ul> <p>This file demonstrates how to set up and run a discrete event simulation using the PyDEVS library.</p>"},{"location":"pydevs_motion_light_system/#stylecss","title":"<code>style.css</code>","text":"<p>This file contains the styling for the web-based visualization of the system. It defines:</p> <ul> <li>Layout of the visualization interface</li> <li>Styling of components and connections</li> <li>Interactive elements for the visualization dashboard</li> </ul> <p>The CSS supports the visualization aspect of the simulation, helping users understand the system structure and behavior.</p>"},{"location":"pydevs_motion_light_system/#devs-conceptual-framework","title":"DEVS Conceptual Framework","text":"<p>The system follows the DEVS formalism which includes:</p> <ol> <li>State-Based Modeling: Components maintain states that change over time</li> <li>Event-Driven Execution: System advances based on events rather than fixed time steps</li> <li>Hierarchical Composition: Simple models are combined to create complex systems</li> <li>Well-Defined Interfaces: Components interact only through input/output ports</li> <li>Time Advance Function: Each component determines when its next internal event occurs</li> </ol>"},{"location":"pydevs_motion_light_system/#simulation-flow","title":"Simulation Flow","text":"<ol> <li>The motion sensor periodically generates motion detection events (0 or 1)</li> <li>These events are sent to the router component</li> <li>The router forwards the events to the appropriate light component</li> <li>The light changes its state (on/off) based on the received values</li> <li>The simulation continues until the specified termination time is reached</li> </ol>"},{"location":"pythonpdevs/","title":"PythonPDEVS","text":""},{"location":"pythonpdevs_installation_guide/","title":"PythonPDEVS Installation Guide","text":"<ol> <li> <p>Prerequisites</p> <ul> <li>Make sure you have Python 3.x installed.</li> <li>You may need pip (Python package manager).</li> <li>Clone the repository Open your terminal or command prompt and run:</li> </ul> <p><pre><code>git clone https://github.com/capocchi/PythonPDEVS.git\n</code></pre> 3. Navigate to the project directory</p> <p><pre><code>cd PythonPDEVS\n</code></pre> 4. Install PythonPDEVS Run the following command to install it using <code>setup.py</code>:</p> <pre><code>python setup.py install\n</code></pre> <p>Alternatively, if you prefer installing in development mode (helpful if you plan to modify the source):</p> <pre><code>python setup.py develop\n</code></pre> </li> </ol>"},{"location":"pythonpdevs_introduction/","title":"PythonPDEVS Introduction","text":"<p>PythonPDEVS is a Python implementation of the Parallel Discrete Event System Specification (PDEVS) formalism. It provides tools to model and simulate systems as a combination of atomic and coupled models, enabling hierarchical and modular system design.</p> <p>Atomic Models:</p> <ul> <li>The basic building blocks of a DEVS system.</li> <li>Define state variables, internal and external transitions, output functions, and time advance functions.</li> <li>Handle input and output events independently.</li> <li>Each atomic model simulates the behavior of a single component.</li> </ul> <p>Coupled Models:</p> <ul> <li>Allow combining multiple atomic models (or other coupled models) into a larger system.</li> <li>Define the connections (couplings) between submodels.</li> <li>Provide hierarchical composition, enabling complex systems to be built from simpler components.</li> <li>Do not define behavior themselves, but manage the structure and communication of submodels.</li> </ul> <p>In PythonPDEVS, you build a system by first creating atomic models (with logic and state changes), then integrating them into a coupled model to define how they interact and exchange events.</p>"},{"location":"saml/","title":"SAML","text":""},{"location":"saml_%28software_architecture_modeling_language%29_guide/","title":"SAML (Software Architecture Modeling Language) Guide","text":""},{"location":"saml_%28software_architecture_modeling_language%29_guide/#overview","title":"Overview","text":"<p>SAML (Software Architecture Modeling Language) is used to model and simulate software architectures, particularly in IoT-based scenarios. It allows users to define components, interactions, and behaviors in a structured manner. This guide provides a step-by-step approach to using SAML for designing a temperature sensor-based automation system.</p>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#caps-environment-in-eclipse","title":"CAPS Environment in Eclipse","text":"<ol> <li>Folder Viewer (on the left)</li> <li>Diagram Canvas (in the center)</li> <li>Pallate(on the right)</li> <li>Connections(on the right)</li> <li>Properties Panel(at the bottom)</li> </ol>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#folder-viewer","title":"Folder Viewer","text":"<p>This displays the file structure. It contains your SAML project, and there is a folder called \u2018model\u2019 where you can create your SAML models.</p>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#diagram-canvas","title":"Diagram Canvas","text":"<p>Items can be taken from the palette and connections to model our SAML.</p> <p></p>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#pallate","title":"Pallate","text":"<p>Pallate contains all the components required for the architecture, such as sensors, timers etc</p> <p></p>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#connections","title":"Connections","text":"<p>Types of connections between the components can be selected from here.</p> <p></p>"},{"location":"saml_%28software_architecture_modeling_language%29_guide/#properties","title":"Properties","text":"<p>Configure the properties of the components used for modelling,</p> <p></p>"},{"location":"saml_for_motion_based_lighting_system/","title":"SAML for Motion Based Lighting System","text":""},{"location":"saml_for_motion_based_lighting_system/#project-description","title":"Project Description","text":"<p>This project implements an automated motion detection and response system using a sensor-controller-actuator architecture. A motion sensor continuously monitors for movement within its detection range. Upon detecting motion, the sensor transmits a signal to a controller (or router) responsible for processing the incoming data. The controller analyzes the signal and, based on predefined logic, sends a command to a light actuator to turn the light on. This system enables responsive, energy-efficient lighting by automating illumination based on occupancy or movement detection, making it ideal for smart home or smart building applications.</p>"},{"location":"saml_for_motion_based_lighting_system/#motion-sensor","title":"Motion Sensor","text":"<ol> <li>Detects Motion every second</li> <li>Sends the data to the controller/router</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#controllerrouter","title":"Controller/Router","text":"<ol> <li>Waits for the message to receive</li> <li>Look for the available nodes/lights</li> <li>Sends the message</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#sensorlight","title":"Sensor/Light","text":"<ol> <li>Receives the message.</li> <li>checks if it's 1 or 0.</li> <li>Turn on/off the light based on the condition.</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#steps-to-create-a-saml-project","title":"Steps to Create a SAML Project","text":""},{"location":"saml_for_motion_based_lighting_system/#1-create-a-new-saml-project","title":"1. Create a New SAML Project","text":"<ol> <li>Open Eclipse and go to <code>File</code> \u2192 <code>New</code> \u2192 <code>Project</code>.</li> <li>Select <code>EMF</code> \u2192 <code>Empty EMF Project</code>.</li> <li>Name the project and select a location (keeping the default workspace location is recommended).</li> <li>Click <code>Finish</code>.</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#2-create-the-saml-model-file","title":"2. Create the SAML Model File","text":"<ol> <li>In the Project Explorer, expand the newly created project.</li> <li>Right-click on the <code>model</code> folder, select <code>New</code> \u2192 <code>Other</code>.</li> <li>Search for <code>CAPSModel</code> and select <code>CAPSSaml</code>.</li> <li>Name the file, ensuring it ends with <code>.capssaml</code></li> <li>Click <code>Next</code>, select <code>Software Architecture</code> from the model object list, and click <code>Finish</code>.</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#3-initialize-the-diagram","title":"3. Initialize the Diagram","text":"<ol> <li>In the Project Explorer, right-click on the new <code>.capssaml</code> file.</li> <li>Select <code>Initialize friends diagram file</code>.</li> <li>Keep the default name and location, and click <code>Finish</code>.</li> <li>The diagram editor will open with an empty canvas.</li> </ol>"},{"location":"saml_for_motion_based_lighting_system/#4-creating-components","title":"4. Creating Components","text":"<p>1. Motion Sensor:</p> <ul> <li>From the palette, select <code>Component</code> and place it on the canvas.</li> <li>In the Properties view, name it <code>MotionSensor</code>.</li> <li>Inside the component, add: <ul> <li><code>Initial Mode</code> (to define its starting behavior).</li> <li><code>StartTimer</code> (to trigger periodic temperature readings).</li> <li><code>SenseOccupancy</code> (to simulate temperature sensing).</li> <li><code>TimerFired</code> (to handle the timer expiration event).</li> <li><code>UnicastSendMessage</code> (to send the motion data).</li> <li></li> </ul> </li> <li>Connect these elements using <code>Behavior Link</code>.</li> <li>Set StartTimer Properties: <ul> <li><code>Cyclic</code> \u2192 <code>True</code></li> <li><code>Name</code> \u2192 <code>MotionTimer</code></li> <li><code>Period</code> \u2192 <code>1000</code> (milliseconds, i.e., every 1 second)</li> </ul> </li> <li>Define <code>Primitive Data Declaration</code>: <ul> <li><code>Name</code> \u2192 <code>MotionData</code></li> <li><code>Type</code> \u2192 <code>Boolean</code></li> <li><code>Value</code> \u2192 <code>0</code></li> </ul> </li> <li>``</li> <li> <p>Select the <code>SenseOccupancy</code> item and, in the properties view, set the following parameters.</p> <ul> <li>Data Recipient \u2192Double click and select the Motion Data</li> <li> <p>Name \u2192SenseMotion</p> <p> - Select the message item and set the following parameters:      - Data \u2192MotionData;     - Data Recipient \u2192Select the Primitive Data Declaration MotionData variable;     - Name \u2192MotionValue </p> </li> </ul> </li> </ul> <p>Now add one OutMessagePort and connect the send MotionValue to the outport using the Send Message Port. You will see something similar to this at this moment:</p> <p></p> <p>2. Controller/Router</p> <ul> <li>Create a <code>Component</code> named <code>Controller</code>.</li> <li>Inside, add: <ul> <li><code>Initial Mode</code></li> <li><code>ReceiveMessage</code> (to get motion data from the sensor)</li> <li><code>Choice</code> (to implement decision-making logic)</li> <li>Two <code>UnicastSendMessage</code> instances (to send <code>On</code> or <code>Off</code> commands)</li> </ul> </li> <li>Define <code>Primitive Data Declaration</code>: <ul> <li><code>Name</code> \u2192 <code>Off</code>, <code>Type</code> \u2192 <code>Boolean</code>, <code>Value</code> \u2192 <code>False</code></li> <li><code>Name</code> \u2192 <code>On</code>, <code>Type</code> \u2192 <code>Boolean</code>, <code>Value</code> \u2192 <code>True</code></li> </ul> </li> <li>Select the message item and set the following parameters for one: <ul> <li>Data \u2192Off;</li> <li>Data Recipient \u2192Select the Primitive Data Declaration Off</li> <li>Name \u2192SendOff</li> </ul> </li> <li>Select the message item and set the following parameters for second: <ul> <li>Data \u2192On;</li> <li>Data Recipient \u2192Select the Primitive Data Declaration On</li> <li>Name \u2192SendOn</li> </ul> </li> <li>Connect elements with <code>Behavior Link</code>: <ul> <li><code>ReceiveMessage</code> \u2192 <code>Choice</code></li> <li><code>Choice</code> \u2192 <code>SendOnMessage</code> (if motion==1)</li> <li><code>Choice</code> \u2192 <code>SendOffMessage</code> (if motion==0)</li> </ul> </li> <li>Add the InMessagePort, connect to the Receive MotionValue using the ReceiveMessage Port, and 2 OutMessagePorts, and connect them to the UniCastSendMessage</li> </ul> <p></p> <p>3.Sensor/Light</p> <ul> <li>Create a <code>Component</code> named <code>Light</code>.</li> <li> <ul> <li>Inside, add:          - <code>Initial Mode</code>         - Two <code>ReceiveMessage</code> instances (one for <code>On</code>, one for <code>Off</code>)         - <code>Actuate</code> (to control the window mechanism)</li> <li>Connect elements with <code>Behavior Link</code>: <ul> <li><code>ReceiveOpenMessage</code> \u2192 <code>Actuate</code> (if 1 = True)</li> <li><code>ReceiveCloseMessage</code> \u2192 <code>Actuate</code> (if 0 = False)</li> </ul> </li> </ul> </li> <li>Now add two InMessagePorts and connect them to the two ReciveMessage using the ReceiveMessagePort</li> </ul> <p>4. Final Connections</p> <ul> <li>Use <code>OutMessagePort</code> and <code>InMessagePort</code> to link using the Connection <ul> <li>MotionSensor -&gt; Router</li> <li>Router(SendOn) to Light(ReceiveOn)</li> <li>Router(SendOff) to Light(ReceiveOff)</li> </ul> </li> </ul> <p>Final Diagram:</p> <p></p> <p>Save it and now, open the File in VSCode or in any code editor to see the XML file generated.</p>"},{"location":"saml_for_temperature_based_window_control/","title":"SAML for Temperature based window control","text":""},{"location":"saml_for_temperature_based_window_control/#project-description","title":"Project Description","text":"<p>We will model a simple scenario: a room equipped with a temperature sensor, an actuator connected to a window, and a server for data storage. The system functions as follows:</p> <ul> <li>The sensor detects room temperature periodically.</li> <li>If the temperature exceeds a threshold, the actuator opens the window.</li> <li>If the temperature is too low, the actuator closes the window.</li> <li>The temperature data is stored on a remote server.</li> </ul>"},{"location":"saml_for_temperature_based_window_control/#temperature-sensor","title":"Temperature Sensor","text":"<ul> <li>Starts a timer to sense temperature every 10 seconds.</li> <li>Reads temperature and sends it to the server.</li> </ul>"},{"location":"saml_for_temperature_based_window_control/#server","title":"Server","text":"<ul> <li>Receives temperature data from the sensor.</li> <li>Stores it in a database.</li> </ul>"},{"location":"saml_for_temperature_based_window_control/#controller","title":"Controller","text":"<ul> <li>Receives temperature values.</li> <li>Decides whether to open or close the window based on thresholds (25\u00b0C and 18\u00b0C).</li> <li>Sends appropriate command (<code>Open</code> or <code>Close</code>) to the actuator.</li> </ul>"},{"location":"saml_for_temperature_based_window_control/#window-actuator","title":"Window Actuator","text":"<ul> <li>Receives commands from the controller.</li> <li>Opens/closes the window accordingly.</li> </ul>"},{"location":"saml_for_temperature_based_window_control/#steps-to-create-a-saml-project","title":"Steps to Create a SAML Project","text":""},{"location":"saml_for_temperature_based_window_control/#1-create-a-new-saml-project","title":"1. Create a New SAML Project","text":"<ol> <li>Open Eclipse and go to <code>File</code> \u2192 <code>New</code> \u2192 <code>Project</code>.</li> <li>Select <code>EMF</code> \u2192 <code>Empty EMF Project</code>.</li> <li>Name the project and select a location (keeping the default workspace location is recommended).</li> <li>Click <code>Finish</code>.</li> </ol>"},{"location":"saml_for_temperature_based_window_control/#2-create-the-saml-model-file","title":"2. Create the SAML Model File","text":"<ol> <li>In the Project Explorer, expand the newly created project.</li> <li>Right-click on the <code>model</code> folder, select <code>New</code> \u2192 <code>Other</code>.</li> <li>Search for <code>CAPSModel</code> and select <code>CAPSSaml</code>.</li> <li>Name the file, ensuring it ends with <code>.capssaml</code>.</li> <li>Click <code>Next</code>, select <code>Software Architecture</code> from the model object list, and click <code>Finish</code>.</li> </ol>"},{"location":"saml_for_temperature_based_window_control/#3-initialize-the-diagram","title":"3. Initialize the Diagram","text":"<ol> <li>In the Project Explorer, right-click on the new <code>.capssaml</code> file.</li> <li>Select <code>Initialize friends diagram file</code>.</li> <li>Keep the default name and location and click <code>Finish</code>.</li> <li>The diagram editor will open with an empty canvas.</li> </ol>"},{"location":"saml_for_temperature_based_window_control/#4-creating-components","title":"4. Creating Components","text":"<ol> <li> <p>Temperature Sensor:</p> <ul> <li>From the palette, select <code>Component</code> and place it on the canvas.</li> <li>In the Properties view, name it <code>TemperatureSensor</code>.</li> <li>Inside the component, add: <ul> <li><code>Initial Mode</code> (to define its starting behavior).</li> <li><code>StartTimer</code> (to trigger periodic temperature readings).</li> <li><code>SenseTemperature</code> (to simulate temperature sensing).</li> <li><code>TimerFired</code> (to handle the timer expiration event).</li> <li><code>UnicastSendMessage</code> (to send the temperature data).</li> </ul> </li> <li>Connect these elements using <code>Behavior Link</code>.</li> <li>Set StartTimer Properties: <ul> <li><code>Cyclic</code> \u2192 <code>True</code></li> <li><code>Name</code> \u2192 <code>TemperatureTimer</code></li> <li><code>Period</code> \u2192 <code>10000</code> (milliseconds, i.e., every 10 seconds)</li> </ul> </li> <li>Define <code>Primitive Data Declaration</code>: <ul> <li><code>Name</code> \u2192 <code>Temperature</code></li> <li><code>Type</code> \u2192 <code>Real</code></li> <li><code>Value</code> \u2192 <code>0.0</code></li> </ul> </li> <li> <p>Server:</p> </li> <li> <p>Create a new <code>Component</code>, name it <code>Server</code>.</p> </li> <li>Inside, add: <ul> <li><code>Initial Mode</code></li> <li><code>ReceiveMessage</code> (to get temperature data from the sensor)</li> <li><code>Server</code> (to process data)</li> <li><code>StoreData</code> (to save the temperature values)</li> </ul> </li> <li>Connect <code>ReceiveMessage</code> \u2192 <code>Server</code> \u2192 <code>StoreData</code> with <code>Behavior Link</code>.</li> <li> <p>Controller:</p> </li> <li> <p>Create a <code>Component</code> named <code>Controller</code>.</p> </li> <li>Inside, add: <ul> <li><code>Initial Mode</code></li> <li><code>ReceiveMessage</code> (to get temperature data from the sensor)</li> <li><code>Choice</code> (to implement decision-making logic)</li> <li>Two <code>UnicastSendMessage</code> instances (to send <code>Open</code> or <code>Close</code> commands)</li> </ul> </li> <li>Define <code>Primitive Data Declaration</code>: <ul> <li><code>Name</code> \u2192 <code>Close</code>, <code>Type</code> \u2192 <code>Boolean</code>, <code>Value</code> \u2192 <code>False</code></li> <li><code>Name</code> \u2192 <code>Open</code>, <code>Type</code> \u2192 <code>Boolean</code>, <code>Value</code> \u2192 <code>True</code></li> </ul> </li> <li>Connect elements with <code>Behavior Link</code>: <ul> <li><code>ReceiveMessage</code> \u2192 <code>Choice</code></li> <li><code>Choice</code> \u2192 <code>SendOpenMessage</code> (if temperature &gt; 25\u00b0C)</li> <li><code>Choice</code> \u2192 <code>SendCloseMessage</code> (if temperature &lt; 18\u00b0C)</li> </ul> </li> <li> <p>Window Actuator:</p> </li> <li> <p>Create a <code>Component</code> named <code>WindowActuator</code>.</p> </li> <li>Inside, add: <ul> <li><code>Initial Mode</code></li> <li>Two <code>ReceiveMessage</code> instances (one for <code>Open</code>, one for <code>Close</code>)</li> <li><code>Actuate</code> (to control the window mechanism)</li> </ul> </li> <li>Connect elements with <code>Behavior Link</code>: <ul> <li><code>ReceiveOpenMessage</code> \u2192 <code>Actuate</code> (if Open = True)</li> <li><code>ReceiveCloseMessage</code> \u2192 <code>Actuate</code> (if Close = False)</li> </ul> </li> </ul> </li> </ol>"},{"location":"saml_for_temperature_based_window_control/#5-connecting-components","title":"5. Connecting Components","text":"<ul> <li>Use <code>OutMessagePort</code> and <code>InMessagePort</code> to link: <ul> <li><code>TemperatureSensor</code> \u2192 <code>Server</code></li> <li><code>Server</code> \u2192 <code>Controller</code></li> <li><code>Controller</code> \u2192 <code>WindowActuator</code></li> </ul> </li> </ul>"},{"location":"simulate_motion_based_lighting_system_in_cup_carbon/","title":"Simulate Motion Based Lighting System in Cup Carbon","text":"<p>Open the CupCarbon and create the project:</p> <p></p> <p>Now, go to the map and select the Notebook view:</p> <p></p> <p></p> <p>Feel free to explore and select the other views as well.</p> <p>Now, let\u2019s create the base path using markers. From the toolbar, select the icon with the sky-blue circle and an arrow, or you can also use the shortcut key number 8. Now you can see the + icon start clicking and draw the path, once you are done right click the mouse.</p> <p>. </p> <p>Once you get a base shape, it\u2019s time to add more markers. These act as steps in the simulation, so the mobile node travels one dot per the given arrow speed. To start, click on the marker and keep pressing 'u'.</p> <p>.  </p> <p>Add as many markers as you need, you can draw any shape, or you can choose map view and draw to points and click Route From Markers from the Marker Parameters section in the slide bar.</p> <p>.  </p> <p>Save the markers drawn as the route from the side menu.</p> <p></p> <p>Now, it\u2019s time to add some sensor nodes. We will be using a total of three types: sensor node, IoT node, and mobile node. We will create two types within the sensor node: one for the controller and one for the sensor. to add the sensor node click on the purple circle from the toolbar or use the shortcut key '1'.</p> <p>Let's now go deeper and make this a sensor node that is supposed to detect the activity. As this sensor will be placed on the path, we created the inner circle should be on the points of the so we will reduce the radius to 20 and then also will keep the radio radius 20. Because keeping this bigger causes the other nearby sensors to be connected. We want the lights to be turned on only when the user is at that point. The same process will be followed for the controller/router. The difference between the sensor and the controller/router is sensor takes the readings, and the controller will forward the readings to the nearby nodes.</p> <p></p> <p>To make it alive, we need logic. So, click on the SenScript Window and add the code for both the sensor and the controller.</p> <p></p> <p>First, we will add the sensor code:</p> <pre><code>atget id id\nloop\ndreadsensor x\ndata message id x\nsend message 0 2\ndelay 1000\n</code></pre> <ul> <li>atget id id \u2192 id = id, my or ch of the sensor node</li> <li>loop \u2192 Starting the loop section</li> <li>dreadsensor x \u2192 x=1 if the sensor detects an event (mobile), x=0, otherwise</li> <li>data message id x \u2192 This line prepares a data message to be sent. It packages the data gathered from the sensor (<code>x</code> is the data being read), and associates it with the ID of the node (<code>id</code>). This message will be sent to another node or system.</li> <li>send message 0 2 \u2192 This sends the message from the sensor node to all nodes within its range. The ID of the node is set to 2 (this should be configured in the panel for the controller node). By doing this, we can broadcast the message to all nodes within range. If we hardcode the ID for each node, we would have to manually change it for every single node, which is inefficient. Broadcasting the message allows for dynamic communication across the network.</li> <li>delay 1000 \u2192 This introduces a delay of 1000 milliseconds (1 second).</li> </ul> <p>and save it with the extension csc.</p> <p>For the controller/router node:</p> <pre><code>atget id id\nloop\nwait \nread message\nrdata message rid x\ndata message2 id x\nsend message2 * rid\n</code></pre> <ul> <li>atget id id \u2192 id = id, my or ch of the sensor node</li> <li>loop \u2192 Starting the loop section</li> <li>wait \u2192 wait for the message</li> <li>read message \u2192 reads the message sent</li> <li> <p>rdata message rid x\u2192 This command extracts data from the received message (stored in <code>message</code>).     The message is assumed to be a string formatted with fields separated by <code>#</code>.</p> <ul> <li>It splits the message into parts.</li> <li>The first part is assigned to <code>rid</code> (the sender\u2019s ID).</li> <li>The second part is assigned to <code>x</code> (the data payload).</li> <li>data message2 id x\u2192This line prepares a data message to be sent. It packages the data gathered from the sensor</li> <li>send message2 * rid\u2192 Sends <code>message2</code> to all nodes in range of <code>rid</code> (the original sender). The <code>*</code> indicates broadcasting to all nodes within range of <code>rid</code>.</li> </ul> </li> </ul> <p>Finally, we will write the logic for the reciving node(IoT node):</p> <pre><code>loop \nwait \nread message\nrdata message rid x\n\nif(x==1)\n    print \"Detected\"\n    mark 1\nelse\n    print \"Not Detected\"\n    mark 0\nend\n</code></pre> <ul> <li>loop \u2192 Starting the loop section</li> <li>wait \u2192 wait for the message</li> <li>read message \u2192 reads the message sent</li> <li> <p>rdata message rid x\u2192 This command extracts data from the received message (stored in <code>message</code>).     The message is assumed to be a string formatted with fields separated by <code>#</code>.</p> <ul> <li>It splits the message into parts.</li> <li>The first part is assigned to <code>rid</code> (the sender\u2019s ID).</li> <li>The second part is assigned to <code>x</code> (the data payload).</li> <li>if condition \u2192 This condition checks if the value received is 1 or not, if 1 it prints Detected and turn on the node else prints Not Detected and keeps the node off or turn the node off.</li> </ul> </li> </ul> <p>After adding the one more node and a IoT node(This can be added using the bulb icon in the toolbar), the screen looks like this:</p> <p></p> <p>Arrows will be automatically added as the nodes are with in the range of the radio of the IoT node by default. now we have to assign the scripts to the nodes to make bring our model to the life.</p> <p>Now i will assign the sensor script to the node id S1 and the router script to the S3(this can be any node number) and to the IOT node my final receving script, to do this i will click on the node and then go to the Device Parameters section and select the respective script file.</p> <p></p> <p></p> <p></p> <p>Make sure you also set the MY value in the Radio Parameter to 2 for router node only. After Assigning screen looks like this, confirm that scripts are loaded. The name of the loaded script will be shown in the side. we now add the mobile node and assign the gps file only to it(the orange dot indicates the gps file is added to it).</p> <p></p> <p>Now its time to run the simulation. Click on the main simulation button, once started then to make the mobile node running go to the Simulation Parameters and run the simulation. Also, ensure that the router is connected to the sensor, if not move it close.</p> <p></p> <p> </p> <p>Now lets add more routers, lights and check our dynamic code logic.</p> <p></p> <p>Now i multplied the router nodes keeping the single sensor node and all the bulbs are conncected to the router nodes, so whenever there is a moment at the sensor node all the bulbs will get turned on. From the sensor the information will be sent to the bulbs through the routers.</p> <p></p> <p></p> <p></p> <p>To make this more intresting, we can multiple the sensor nodes and the router nodes where the one sensor node will send the information to only one router and the router will send the information to the nearby bulbs, This simulates the motion based lighting. Here is the complete example:</p> <p></p> <p>Hiding all the details, it will look like this</p> <p></p> <p>During Simulation:</p> <p></p> <p></p> <p>All the redlines indicate the data flow between the nodes. Now the whenever the mobile node is detected it will send the information to the router and the router sends to the nearby bulbs on command.</p> <p>The cup carbon code files for the shown example can be found at: https://github.com/likhithkanigolla/IIITS-Demo/tree/main/FinalCupCarbon-Demo</p>"}]}